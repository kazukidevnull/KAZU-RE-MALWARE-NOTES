## RE Analysis Notes overview
 
This Directory is for various notes regarding RE analysis and below you will find various notes in relation to doing RE Analysis and such, due to the nature everything, a lot of the notes found in the "malware analysis notes" document will naturally be used for general RE as well as things such as packinging, encryption, obfuscation, etc is common on many applications

This file will start with all the main category and topics listed at the start for easy overview and then go into details about each category past it which will contain details about the various things listed at the start, 
 
the overview part also function as a way for me to quickly note down things i remember/come across to write more details about later, so there will be a lot more in the overview then there's information about them.

------------
## Index:

-- Packers:
-- Indentifying Packers
-- Dealing with Packers
-- The automatic way
-- The Manual Way
-- The Manual Way
-- Anti Analysis Notes


----------
## DETAILS:

### Packers

There many kinds of packers, some are made for benign purposes while others are made specially for hiding something and make analysis of the file harder

one of the most commonly popular packers are 
+ UPX: The most common used packers out there and the most often encountered type of packer since it's open source, it can be unpacked using cmd
+ ASPack: This is a commonly used packer which has a free and a premium version. The same company that provides ASPack also provides protectors such as ASProtect.



### Indentifying Packers

there are many way to identify if file is packaged and by what, some are very easy and some are more involved, on the easier side theres tools such as "PEiD" or CFF explorer to check the PE of the file as all packers have their own characteristics which help ID them:
+ UPX Packer: renames as sections as "UPX1", "UPX2" and so forth
+ ASPack: Names the last section ".aspack"

sometimes you need to look a little harder to find out what packer was used, An unpacked PE file contains sections such as .text or .code, .data, .idata, .rsrc, and .reloc, while packed files can contain specific section names, such as UPX0, .aspack, .stub, and so on, if you find a section name with unknown name, then google it may help.
  
most packers also compress the file sections which include the code & data section, including the import table and so forth, and then add a new section at the end which contains the code to unpack everything again, due to all this, execution is normally started from the last section which is a clear indication of decryption is done, other signs include: 
+  The entry point is not pointing to the first section (it would mostly be pointing to one of the last two sections) and this section's memory permission is EXECUTE (in the section's characteristics)
+ The first section's memory permission will be mostly READWRITE


For most applications, the import table is full of APIs from system libraries, as well as thirdparty libraries; however, in most of the packed PE files, the import table will be quite small, and will include a few APIs from known libraries. This is enough to unpack the file.

Only one API from each library of the PE file would be used after being unpacked. The reason for this is that most of the packers load the import table manually after unpacking the PE file

### Dealing with Packers

#### The automatic way

Method 1:

some packers such as UPX are "self-extracting" packages, since they are made to just make it easier to move the file around, they often include a way to unpack them easily,

Method 2:

Using OllyScript with OllyDbg

There is an OllyDbg plugin called OllyScript that can help automate the unpacking process. It does this by scripting OllyDbg actions, such as setting a breakpoint, continuing execution, and pointing the EIP register to a different place or modifying some bytes. 

Nowadays, OllyScript is not widely used, but is nice to be aware of it.

Method 3 

Using "generic unpacker" such as "QuickUnpack"

Generic unpackers have been created to automate manual unpacking or unpack specific packers

They are more generic and can work with multiple packers, even if the packers were not designed to unpack their files: however, malware can easily escape from these tools, which may lead to the execution of the malware on the user's machine. Because of this, you should always use these tools on a virtual machine or in a safe environment.

Method 4:

Using Emulation tool like libemu and the Pokas x86 Emulator to run the code without actually running it

one way to do this using "Pokas x86" for UPX would be:

```

from pySRDF import * emu = Emulator("upx.exe") x = emu.SetBp("__isdirty(eip)") #which set bp on Execute on modified data emu.Run() # OR emu.Run("ins.log") to log all running instructions emu.Dump("upx_unpacked.exe",DUMP_FIXIMPORTTABLE) #DUMP_FIXIMPORTTABLE create new import table for new API print "File Unpacked Successfully\n\nThe Disassembled Code\n----------------"

```

Method 5

Doing Memory dumps

The last technique we will mention is incorporating memory dumps. This technique is widely used, as it's one of the easiest for most packers and protectors to use (especially if they have anti-debugging techniques), as it basically involves executing the malware and taking a memory snapshot of its process and every process it injects code into.

This technique is very beneficial for static analysis, as well for static signature scanning; however, the memory dump that is produced is different from the original sample and can't be executed. The addresses and the import table need to be fixed before any further dynamic analysis is possible.

many RE people prefer to just dump the memory and hope to be lucky, but as mentioned, this has many disadvantages, including also:  

+ It is possible that the unpacked sample will already be mapped by sections and that the import table will already have been populated, so the engineer will have to change the physical addresses of each section to be equal to the virtual ones, restore imports, and maybe even handle relocs in order to make them executable again. The hash of this sample will be different from the original one.
+ The original loader may unpack the sample to allocated memory, inject it somewhere else, and free the memory so that it won't be a part of the full dump.
+ It is very easy to miss some modules; for example, the original loader may unpack only a sample for a 32- or 64-bit platform.

Since this technique doesn't provide a clean sample, and because of the limitations of the previous automated techniques described, it is recommended doing a manual unpacking over using memory dumps.

#### The Manual Way

Method 1

Manual unpacking using OllyDbg:




#### The Manual Way

Method 1

Manual unpacking using OllyDbg:

First enable DEP(Data Execution Prevention) in windows to prevent execution of processes even if non-critial ones

then set memory breakpoint on execution by changing the sections permission by going to memory window ("view > memory") and then right click first memory section of the file like "UPX0" for UPX and and slect "Read/Write" under "set access".

sometimes malwares tries to modify itself to change access back to "full access" by modfying the permissions using "VirtualProtect"s API for instance.

by setting a breakpoint on the API such as "virtualProtect" you can break if the program tries to change permissions, to find it, you can right click on the CPU disassemble area and select "Go to > Expression"(or just hit CTRL-G) and search for the API

once you run the program it should break on OEP, but sometimes some packers modifies the first couple of bytes of the first section with instructions such as "ret", "jmp", "call", but after a few iterations the program will break, which occur after full decryption/decompresssion.

Method 2

Call stack backtracing

Using the call stack to captured a unpacked package is one of the ways that can be fast and efficient and works most of the time.

We archive this by setting breakpoints that we are sure will make the debugged process to break in the middle of executing the decrypted code which lets us then backtrack to the beginning of the decrypted code and then declare that as OEP.

to be able to do this properly you should optimally have knowledge of what API's is used to execute at some point, these will normally be gained trough behaviour analysis or a sandbox report, but you can also just guess using some of the common API used such as 

+ GetModuleFileNameA
+ GetCommandLine
+ CreateFileA
+ VirtualAlloc
+ HeapAlloc
+ memset

once you figure out what API to look for you add a breakpoint to them all, except the ones that could be used by the unpacking stub, and then execute the program until the execution breaks

then just follow the call stack until you find the first return address, then follow the return address on the disassembled section in the CPU viewer, once you have reached the first call in the unpacked section, then you only need to to find the OEP by looking a bit further up,

WARNING: this method, for obvious reasons, can lead to the exxecution of the file you are drying to reverse
### 

METHOD 3

monitoring memory allocated spaces for unpacked code

if time is limited or have a lot of samples, then this method may be suitable as it won't go until the details of how the sample is actually stored.

Often, malwares(and non malwares) often allocate a big block of memory to store the unpacked/decrypted file, although, this is not always the case.

There exist numerous API's in windows to allocate memory in user mode, but the most common ones are:

+ VirtualAlloc/VirtualAllocEx
+ LocalAlloc
+ GlobalAlloc
+ HeapAlloc

for kernal mode, there's following API which pretty much does the same as the ones listed above:

+ RtlAllocateHeap
+ ZwAllocateVirtualMemory
+ ExAllocatePoolWithTag

Also, if the sample are in C then looking for the "malloc/calloc" function will be a logical thing to do, for C++ the "new" operator is also worth monitoring.

You can set breakpoint on execution as long as you break at the entry point or beginning of the TLS routine, while it's usually file setting breakpoint at the first function instruction, there's still the possibility of it getting "hooked" and get it's first bytes replaced with custom code for anti-RE reasons, in this case, setting the breakpoint at the last instruction may work better 

after this is done you can then resume execution and monitoring the allocated block size, as long as it's big enough, you can put a breakpoint on write access to intercept it when it starts getting written to, if the functions are called too many times, it's best to place a conditional breakpoint which only break over a certain size.

if the block is still encrypted after this, we can keep a breakpoint on writes and wait until the decryption routine starts processing it, after last byte is decrypted/unpacked we can dump the memory to disk.

Other API functions that can be used in the same approach include the following:

+VirtualProtect: Malware authors can use this in order to make the memory block storing the unpacked sample executable
+WriteProcessMemory: Often used in order to inject the unpacked payload, either to some other process or to itself

In normal cases, when the file is decrypted/unpacked, it usually have the correct "MZ-PE" file, which can of course be analysed using other PE-tools, but this is not always the case, 

sometimes the decrypted block is a corrupt executable which depends on the original packer to function correctly 

or, the packer decrypts the sample is decrypted section by section and loads each of them one at a time instead of all at once, this can be handled in following ways:

+ Dump sections as long as they become available and concatenate them later
+ Modify the decryption routine to process the whole sample at once
+ Write a script that decrypts the whole encrypted block


Also, if the decrypted/unpacked programs fail to run properly, it can very much be the case it either need some parameters to run or be  loaded in a specific way, Anti-RE functions may be the reason as well which need to be bypassed, in which case, set a breakpoint just before the sample terminates (such at "ExitProcess", "TerminateProcess" or the more fancy "PostQuitMessage") and look for what is responsible for ti

Since it's quicker, some prefer avoid going into the sub-routines of when manually going trough the functions and only do such when needed.

Method 4:

in-place unpacking

while not common, it's possible to decrypt/unpack in the same section as the encrypted/packed sample, this section should also have write permission.

To find the encrypted block, look for places with big encrypted block, which usually have high entropy, then once you found it, find the exact place where it will start to read and set a breakpoint on read and/or write on it, the first couple of bytes of the block may sometimes also have other metadata worth looking for that may have checksums/hashes be used to verify the decryption and such.

run the program and wait for break.

set a breakpoint on execution or the last written byte of the encrypted block and then dump it.

This method can also be used for samples that relies on allocating memory.

Method 5:

Stack Restoration-based

This method is usually quicker then the last two method mentioned, but is very much not a reliable method and is mostly only suitable for quick check before using other methods, i considered not including this for this reason, but is good to be aware of it.

The idea here is that some packers keep the stack in order and transfer control to the unpacked sample when it has the same stack level that they started with. What that means is that it will access the value located at the address that was originally pointed by the frame pointer register (ebp/rbp), minus one value of a size of the address length for the selected architecture (for example, a 4-byte DWORD for a 32-bit platform) just before transferring control to the unpacked code, even when using the jmp instruction

In this case, it is possible to set a breakpoint on access to the [ebp-4] value while staying at the entry point of the sample and then executing it so that the breakpoint will hopefully trigger just before transferring control to the unpacked code. Often, this happens when the packer restores the registers to the original valuesâ€”for example, by using the popad instruction.

Obviously, this may never happen, depending on the implementation of the unpacking code, and there may be other situations where this does happen (for example, when there are multiple garbage calls before starting the actual unpacking process).

## Anti Analysis Notes

This section will have various notes about things related to analysing of files and various things to note in regards to anti-analysis

String anti analysis:
+ trying to hide strings by pushing them onto the stack, so this is something which may be the case if you see alot of push instructions

