## This document is for all various notes in regards to windows files such ass PE's, DLL's and other windows specific files which may be of interest for RE purposes and how they are structure.


## INDEX

+ PE
+ DLL

--------------

## PE

General facts about the structure of a PE file
+ keeps code and data separated in each their own sections which make it easier to manage data separately from the program and possible to link strings back in assembly
+ sectors have their own memory permissions which enables additional layers of security by giving the system ability to limit what sectors are allowed to access what page of memory(a page of memory is 0x1000 bytes or 4,096 bytes).
+ Data is compressed inside the PE file which is expanded in memory upon execution, this allows creating space for uninitialized variables and such.
+ supports dynamic linking via export and import table
+ supports relocation
+ supports resource sections which can contain additional files, images or icons used by the PE
+ Portable for multiple CPU's, subsystems, devices and platforms

### PE Structure in Details


#### PE Header

Contains information related to
+ Supported systems
+ memory layout for sections related to code and data such as strings, images and such
+ Load and Execution matadata

DOS header Starts with MZ and end with the "e_lfanew" field, which points to the start of the PE header

PE Header starts with two letters, "PE", followed by "File header" and the "Optional header" and later, all additional headers pointed to by the Data directory array

file header values:
+ Signature(50 45 00 00)
+ Machine: indicates the processor type
+ NumberOfSections: this indicate number of sections that follow the header such as data, code or resource sections
+ SizeOfOptionalHeader: indicate the size of optional header
+ Characteristics: tells if it's a exe, program, DLL or driver
+ TimeDateStamp: exact data the program was compiled(warning, som compilers mess with this)

#### Optional header

The optional header comes with lot more more information then the File header which is as follows:
+ Magic: tells if it's a x86 or x64 platform
+ AddressOfEntryPoint: points to the start of the program execution(the first assembly instruction executed in the program)
+ ImageBase: This is the memory address it want to load the program to(default is 0x400000), if the program have a relocation section it can be moved elsewhere if something already exist there
+ SectionAlignment: this indicate the size each section and headers should be in while loaded in memory, normally 0x1000.
FileAlignment: The size of each section in the PE file (and as well the size of all headers) has to be aligned to this number (for example, for a section with size 0x1164 and file alignment 0x200, the section size will be changed to 0x1200 on the hard disk).
+ MajorSubsystemVersion: This indicate the minimum windows version allowed to run the application.
+ SizeOfImage: Size of the whole application in memory, which are usually larger then the file itself.
+ SizeOfHeaders: size of all headers
+ Subsystem: indicate what subsystem application is for.
+ NumberOfRvaAbdSizes:

#### Data directory
The Data directory array points to the other optional headers that might be included in the executable and are not necessary included in every application.

It includes 16 entries following this format:
+ Address: This points to the beginning of the header in memory (relative to the start of the file).
+ Size: This is the size of the header.

The Data directory array includes many different values; some important
for malware analysis, but some of the important blocks to mention are as follows:

+ Import table: This represents the code functions (or APIs) that this program doesn't include but wants to import from other executable files or libraries of code (or DLLs).
+ Export table: This represents the code functions (or APIs) that this program includes in its code and is willing to export and allow other applications to use, rather than rewrite them from scratch.
+ Resource table: This is always located at the start of the resource section and its purpose is to represent the packages' files with the program, such as icons, images, and others.
+ Relocation table: This is always located at the start of the relocation section and it's used to fix addresses in the code when the PE file is loaded to another place in memory.
+ TLS table: Thread Local Storage could be used to bypass debuggers.

#### Section Table

Following the 16 entries of the Data directory array come the section headers. This is a list
of headers with each header representing a section of the PE file. The number of headers in
total is the exact number stored in the NumberOfSections field in FileHeader.

The section header is a very simple header and have the following information:
+ Name: The name of the section (8 bytes max).
+ VirtualAddress: The pointer to the beginning of the section in memory (relatively to the start of the file). These types of addresses are called RVA addresses.
+ VirtualSize: The size of a section (in memory).
+ SizeOfRawData: The size of a section (on the hard disk).
+ PointerToRawData: The pointer to the beginning of the section in the file on the hard disk (relatively to the start of the file). These types of addresses are called offsets.
+ Characteristics: Memory protection flags (EXECUTE, READ, or WRITE).

### PE+ (x64 PE)

PE+ header is very similar to the old PE header with very few changes as follows:
+ ImageBase: It is 8 bytes instead of 4 bytes.
+ BaseOfData: This was removed from the Optional header.
+ Others: Some other fields, such as SizeOfHeapCommit, SizeOfHeapReserve, SizeOfStackReserve, and SizeOfStackCommit are now 8 bytes instead of 4 bytes.
+ Magic: This value changed from 0x10B (representing x86) to 0x20B (representing x64).

PE+ files stayed with the maximum 2 GB size, and all other RVA addresses, including
AddressOfEntrypoint, remained 4 bytes.

### Static/Dynamic Linking

In this section, we will cover the code libraries that were introduced in early operating
systems to speed up the software development and improve the the ability of cooperation
between different teams within a company to produce software.

These libraries were a known target for malware families as they can be easily injected into
the memory of different applications and impersonate them to disguise their malicious
activities.

#### Static linking
With the increasing number of applications on different operating systems, the developers found that there were a lot of code reuse and rewriting of the same logic over and over again to support certain functionalities in their programs. And because of that, the invention of code libraries came in handy.

Code libraries (.lib) include lots of functions to be copied to your program when required, so there is no need to reinvent the wheel and rewrite these functions again (for example, rewriting the code for the mathematical operations such as sin or cos for any application that deals with mathematical equations).This is done by a program called a linker, which basically copies the needed functions into a program and generates the executable file with all the needed functions inside. This process is called the static linking.

#### Dynamic linking
Statically linked libraries lead to having the same code copied over and over again inside each program that might need it, which in turn leads to the loss of hard disk space and increases the size of the executable files.

In modern operating systems such as Windows and Linux, there are hundreds of libraries, and each one has thousands of functions for UI, graphics, 3D, internet communications, and more. Because of that, static linking appeared to be limited and to mitigate this issue, dynamic linking emerged. It allowed programs to expand more and become more functionality-rich, as we see today:

Dynamic linking works in the following way: instead of storing the code inside each executable, any needed library is loaded beside each application in the same virtual memory, so that this application can directly call the required functions. These libraries are named Dynamic Link Libraries (DLLs),

## DLL

DLL is a complete PE file that includes all the headers, sections, and most importantly, the
export table.

The export table includes all the functions that this library exports. Not all library functions are exported as some of them are for internal use. But the functions that are exported can be accessed through its name or its ordinal number (index number), and they are called Application Programming Interfaces (APIs).

Windows provides lots of libraries for Windows programmers to access its functionality, and some of these libraries are as follows:

+ kernel32.dll: This library includes the basic and core functionality for all programs, including reading a file and writing a file.
+ ntdll.dll: This library exports Windows native APIs; kernel32.dll uses this library as a backend for its own functionality. Some malware writers try to access undocumented APIs inside this library to make it harder for reverse engineers to understand the malware functionality, such as LdrLoadDll.
+ user32.dll: This library is used mainly for the Windows GUI.
+ advapi32.dll: This library is used mainly for working with the registry and encryption.
+ shell32.dll: It is responsible for shell operations such as executing files and opening files.
+ ws2_32.dll: All functionality related to internet sockets and network communications (very important for understanding custom network communication protocols).
+ wininet.dll: HTTP and FTP functions, including proxies and more.
+ urlmon.dll: This is an add-on to wininet.dll that's used for working with URLs, web compression, downloading files, and more.
+ gdi32.dll: This is used for simple graphics functionality.


