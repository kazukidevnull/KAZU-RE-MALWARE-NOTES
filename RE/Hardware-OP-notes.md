# Hardware OP NOTES
 
This Document is for various notes regarding how various hardware such as memory, processors, and such operates in details in relation to doing RE.

--------




------------------------------

# CISC

## Intel assembly

### IA.32 and x64 registers table

| x64  | x86 | |  | NOTES  |  |
| ---- | ------- | ------ | ---- | ---- | ---- |
| 8 bytes | 4 bytes | 2 bytes | 1 bytes |
| rax | eas | ax | al, ah |
| rcx | ecx | cx | cl, ch |
| rdx | edx | dx | dl, dh |
| rbx | ebx | bx | bl, bh |
| rsp | esp | sp | spl* | Can be accessed only in x64. |
| rbp | ebp | bp | bpl* | Can be accessed only in x64. |
| rsi | esi | si | sil* | Can be accessed only in x64. |
| rdi | edi | di | dil* | Can be accessed only in x64. |
| r8-r15 \| | r8d-r15d* | r8d-r15w* | r8d-r15b* | r8 to r15 are available only in x64 and not in IA-32 |


The first four registers (rax, rbx, rcx, and rdx) are General-Purpose Registers (GPRs), but
some of them have the following special use cases for certain instructions:
+ rax/eax: This is used to store information and it's a special register for some calculations
+ rcx/ecx: This is used as a counter register in loop instructions
+ rdx/edx: This is used in division to return the modulus

In x64, the registers from r8 to r15 are also GPRs that were added to the available GPRs.

The rsp/esp register is used as a stack pointer that points to the top of the stack. Its value
decreases when there's a value getting pushed to the stack, and increases, when there's a
value getting pulled out from the stack. 

The rbp/ebp register is used as a frame pointer and it's helpful for accessing the function's local variables and arguments

rbp/ebp is sometimes used as a GPR for storing any kind of data rsi/esi and rdi/edi are used mostly to define the addresses when copying a group of
bytes in memory. The rsi/esi register always plays the role of the source and the rdi/edi
register plays the role of the destination. Both registers are non-volatile and are also GPRs.

### Special Registers 

There are two special registers in intel assembly which are:
+ rip/eip: This is a instruction pointer that points to the next instruction to be executed. it CANNOT be accessed directly but there are special instructions to access it
+ rflags/eflags/flags: This register contains the current state of the processor. its flags are affected by the arithmetic and logic instructions including comparison instructions such as "cmp" and "test", and it's used with conditional jumps and other instruction as well. 

#### Most common flags
+ Carry Flag(CF): This flag is set when a arithmetic goes out of bounds

    ex: 
    ```
    mov al, FFh ;al = 0xFF & CF = 0 
    add al, 1 ;al = 0 & CF =1
    ```

+ Zero Flag(ZF): This flag is set when the arithmetic or a logic operation's result is zero. this could also be set with compare instructions 
+ Sign Flag(SF): This flag indicates that the result of the operation is negative.
+ Overflow Flag(OF): This flag indicates that an overflow occured in an operation, leading to a change of a sign(Only on signed numbers)
    
    ex: 
    ```
    mov cl, 7Fh ;cl = 0x7F (127) & OF = 0 
    inc cl ;cl = 0x80 (-128) & OF = 1
    ```
+ MMX:
+ FPU


### opcodes

+ Nop:
+ Pushad:
+ popad:
+ movsb:
+ pop:
+ push
+ add
+ sub

dest:
+ REG; a register such as eax and edx
+ r/m: a place in memory
+ a value in the stack
 
src: represent the source of another value in the calculations, but it doesn't save the result afterward, 
+ REG: such as "add rcx, r8"
+ r/m: such as "add ecx, dword ptr \[00401000h \] 
+ imm: and immediate value such as " mov eax, 00100000h

NOTE: 
+ pushad and popad are not available in x64

Data manipulation instructions:

Some of the arithmetic instructions are as follows:
| Instruction | Structure | Description |
| ----------- | --------- | ----------- |
| add/sub | add/sub dest, src | dest = dest + src/dest = dest - src |
| inc/dec | inc/dec dest | dest = dest + 1/dest = dest - 1 |
| mul | mul src | (Unsigned multiply) rdx:rax = rax * src |
| div | div src | rdx:rax/src (returns the result in rax and the remainder/modulus in rdx) |

for logic and bits manipulation, they are like this:
| Instruction | Structure | Description |
| ----------- | --------- | ----------- |
| or/and/xor | or/and/xor dest, src | dest = dest & src/dest = dest | src/dest =
dest ^ src |
| not | not dest | dest = !dest (the bits are flipped)

for shifts and rotations they are like this:
| Instruction | Structure | Description |
| ----------- | --------- | ----------- |
| shl/shr | shl/shr dest, src (the dest register's maximum number of bits such as 32 or 64) | dest = dest << src/dest = dest >> src (shifts the dest register's bits to the left or the right, which is the same effect as multiplying or dividing by two src times) |
| rol/ror | rol/ror dest, src (same as shl and shr) | Rotates the dest register's bits left or right |

Data transfer instructions
There's a mov instruction, which copies a value from src to dest. This instruction has
multiple forms, as we can see in this table:
| Instruction | Structure | Description |
| ----------- | --------- | ----------- |
1 mov | mov dest, src | dest = src |
| movsx/movzx | movsx/movzx dest , src | src is smaller than dest (src is 16-bits and dest is 32-bits) movzx: Sets the remaining bits in dest to zero movsx: Preserves the sign of the src valuee | 

Other instructions related to stack are like this:
| Instruction | Structure | Description |
| ----------- | --------- | ----------- |
| push/pop | push/pop dest | Pushes the value to the top of the stack (esp = esp - 4)/ pulls the value out of the stack (esp = esp + 4) |
| pushad/popad | pushad/popad | Saves all registers to the stack/pulls out all registers from the stack (in x86 only) |

For string manipulation, they are like this:
| Instruction | Structure | Description |
| ----------- | --------- | ----------- |
| lodsb/lodsw/lodsd/lodsq | lodsb/lodsw/lodsd/lodsq | Loads a byte, 2 bytes, 4 bytes, or 8 bytes from the address rsi/esi into al/ax/eax/rax |
| stosb/stosw/stosd/stosq | stosb/stosw/stosd/stosq |  Stores a byte, 2 bytes, 4 bytes, or 8 bytes at the address rdi/edi from al/ax/eax/rax |
| movsb/movsw/movsd/movsq | movsb/movsw/movsd/movsq |Copy a byte, 2 bytes, 4 bytes, or 8 bytes from the address rsi/esi to the address rdi/edi |

Flow control instructions
Some of the unconditional redirections are as follows:
| Instruction | Structure | Description |
| ----------- | --------- | ----------- |
| jmp | jmp \<relative address\> jmp DWORD/QWORD ptr [Absolute Address] | The relative address is calculated from the start of the next instruction after jmp to the destination |
| call | call \<relative address\> call DWORD/QWORD ptr [Absolute Address] | Same as jmp but it saves the return address in the stack
| ret/retn | ret imm | Pulls the return address from the stack, for some calling conventions cleans the stack from the pushed arguments, and jumps to that address

Some of the conditional redirections are as follows:
| Instruction | Structure | Description |
| ----------- | --------- | ----------- |
| jnz/jz/jb/ja | jz/jnz \<relative address\> | Similar to jmp, but jumps based on a condition |
| loop | loop \<relative address\> | Similar to jmp, but it decrements rcx/ecx and jumps if it didn't reach zero (uses rcx/ecx as a loop counter) |
| rep | rep opcode dest, src(if needed)| rep is a prefix that is used with string instructions; it decrements rcx/ecx, and repeats the instruction until rcx/ecx reaches zero |


### stdcall

The stack, rsp/esp, and rbp/ebp registers do most of the work when it comes to arguments
and local variables. The call instruction saves the return address at the top of the stack
before transferring the execution to the new function, and the ret instruction at the end of
the function returns the execution back to the caller function using the return address saved
in the stack. 

For stdcall, the arguments are also pushed in the stack from the last argument to the first like this 

```
Push Arg02
Push Arg01
Call Func01
```

### cdecl

cdecl (which stands for c declaration) is another calling convention that was used by
many C compilers in x86. It's very similar to stdcall, with the only difference being that the
caller cleans the stack after the callee function (the called function) returns like this:

```
Caller:
push Arg02
push Arg01
call Callee
add esp, 8 ;cleans the stack
```

### fastcall
The __fastcall calling convention is also widely used by different compilers, including
Microsoft C++ compiler and GCC. This calling convention passes the first two arguments in
ecx and edx, and pushes the remaining arguments to the stack. It's only used in x86 as
there's only one calling convention for x64 on Windows.

### thiscall
For object-oriented programming and for the non-static member functions (such as the
classes' functions), the C compiler needs to pass the address of the object whose attribute
will be accessed or manipulated using it as an argument.

In GCC compiler, thiscall is almost identical to the cdecl calling convention and it
passes the object address as a first argument. But in the Microsoft C++ compiler, it's similar
to stdcall and it passes the object address in ecx. It's common to see such patterns in some
object-oriented malware families.

### The x64 calling convention
In x64, the calling convention is more dependent on the registers. For Windows, the caller
function passes the first four arguments to the registers in this order: rcx, rdx, r8, r9, and
the rest are pushed back to the stack. While for the other operating systems, the first six
arguments are usually passed to the registers in this order: rdi, rsi, rdx, rcx, r8, r9, and
the remaining to the stack.
In both cases, the called function cleans the stack after using ret imm, and this is the only
way to clean up stack for these operating systems in x64.

## RISC

### ARM

Advanced RISC Machine is the most typical processors used anything that need to be mobile and energy efficient such as IoT, phones, consoles, and other electronics, it's maybe not as powerful as CISC processors, but they make up for it in other areas.

Overall, the following ARM architecture profiles are available:

+ Application profiles (suffix A, for example, the Cortex-A family): This implements a traditional ARM architecture and supports a virtual memory system architecture based on a Memory Management Unit (MMU). These profiles support both ARM and Thumb instruction sets (as discussed later).

+ Real-time profiles (suffix R, for example, the Cortex-R family): This implements a traditional ARM architecture and supports a protected memory system architecture based on a Memory Protection Unit (MPU).

+ Microcontroller profiles (suffix M, for example, the Cortex-M family): This implements a programmers' model and is designed for integration into Field Programmable Gate Arrays (FPGAs).Each family has its own corresponding set of associated architectures (for example, the Cortex-A 32-bit family incorporates ARMv7-A and ARMv8-A architectures), which in turn incorporate several cores (for example, ARMv7-R architecture incorporates Cortex- R4, Cortex-R5, and so on).

ARM is a load-store architecture; it divides all instructions into the following two
categories:
+ Memory access: Moves data between memory and registers
+ Arithmetic Logic Unit (ALU) operations: Does computations involving registers

ARM supports arithmetic operations for adding, subtracting, and multiplying, and some
new versions, starting from ARMv7, also support division operations. It supports bigendian
order, and uses the little-endian format by default.

There are 16 registers visible at any time on the 32-bit ARM: R0-R15. This number is
convenient as it takes only 4 bits to define which register is going to be used. Out of them,
13 (sometimes referred to as 14, including R14 , or 15, also including R13) are generalpurpose
registers: R13 and R15 each have a special function while R14 can take it
occasionally. Let's have a look at them in greater detail:

+ R0-R7: Low registers are the same in all CPU modes.
+ R8-R12: High registers are the same in all CPU modes except the Fast Interrupt Request (FIQ) mode not accessible by 16-bit instructions.
+ R13 (also known as SP): Stack pointer—points to the top of the stack, and each CPU mode has its own version of it. It is discouraged to use it as a GPR.
+ R14 (also known as LR): Link register—in user mode it contains the return address for the current function, mainly when BL (Branch with Link) or
+ BLX (Branch with Link and eXchange) instructions are executed. It can also be used as a GPR if the return address is stored on the stack. Each CPU mode has its own version of it.
+ R15 (also known as PC): Program counter, points to the currently executed command. It's not a GPR.

Altogether, there are 30 general-purpose 32-bit registers on most of the ARM architectures
overall, including the same name instances in different CPU modes.

+ Apart from these, there are several other important registers, as follows:
+ Current Program Status Register (CPSR): This contains bits describing a current processor mode, a processor state, and some other values.
+ Saved Program Status Registers (SPSR): This stores the value of CPSR when the exception is taken, so it can be restored later. Each CPU mode has its own version of it, except the user and system modes, as they are not exception-handling modes.
+ Application Program Status Register (APSR): This stores copies of the ALU status flags, also known as condition code flags, and on later architectures, it also holds the Q (saturation) and the greater than or equal to (GE) flags.

The number of Floating-Point Registers (FPRs) for a 32-bit architecture may vary,
depending on the core, up to 32.

ARMv8 (64-bit) has 31 general-purpose X0-X30 (R0-R30 notation can also be found) and 32
FPRs accessible at all times. The lower part of each register has the W prefix and can be
accessed as W0-W30.
There are several registers that have a particular purpose, as follows:

| Name | Size | Description |
| ---- | ---- | ----------- |
| XZR/WZR | 64/32 bits, respectively | Zero register |
| pc | 64 bits | Program counter |
| SP/WSP | 64/32 bits, respectively | Current stack pointer |
| ELR | 64 bits | Exception link register |
| SPSR | 32 bits | Saved processor state register |

ARMv8 defines four exception levels (EL0-EL3), and each of the last three registers gets its
own copy of each of them; ELR and SPSR don't have a separate copy for EL0.

There is no register called X31 or W31; the number 31 in many instructions represents the
zero register, ZR (WZR/XZR). X29 can be used as a frame pointer (which stores the original
stack position), and X30 as a link register (which stores a return value from the functions).

Regarding the calling convention, R0-R3 on the 32-bit ARM and X0-X7 on the 64-bit ARM
are used to store argument values passed to functions with the remaining arguments
passed through the stack if necessary, R0-R1 and X0-X7 (and X8, also known as XR
indirectly) to hold return results. If the type of the returned value is too big to fit them, then
space needs to be allocated and returned as a pointer. Apart from this, R12 (32-bit) and X16-
X17 (64-bit) can be used as intra-procedure-call scratch registers (by so-called veneers and
procedure linkage table code), R9 (32-bit) and X18 (64-bit) can be used as platform registers
(for OS-specific purposes) if needed, otherwise they are used the same way as other
temporaries.

As previously mentioned, there are several CPU modes implemented according to the
official documentation, as follows:

| Operating mode name | Abbreviation | Description |
| ------------------- | ------------ | ----------- |
| User | usr | Usual program execution state, used by most of the programs |
| Fast interrupt | fiq | Supports data transfer or channel process |
| Interrupt | irq | Used for general-purpose interrupt handling |
| Supervisor | svc | Protected mode for the OS |
| Abort | abt | Is entered after a data abort or prefetch abort exception |
| System | sys | Privileged user mode for the OS. Can be entered only from another privileged mode by modifying the mode bit of the CPSR |
| Undefined | und | Is entered when an undefined instruction is executed |

#### Instruction sets

There are several instruction sets available for ARM processors: ARM and Thumb. A
processor that is executing ARM instructions is said to be operating in the ARM state and
vice versa. ARM processors always start in the ARM state, and then a program can switch
to the Thumb state by using a BX instruction. Thumb Execution Environment (ThumbEE)
was introduced relatively recently in ARMv7 and is based on Thumb, with some changes
and additions to facilitate dynamically generated code.

ARM instructions are 32 bits long (for both AArch32 and AArch64), while Thumb and
ThumbEE instructions are either 16 or 32 bits long (originally, almost all Thumb
instructions were 16-bit, while Thumb-2 introduced a mix of 16- and 32-bit instructions).

All instructions can be split into the following categories according to the official
documentation:


| Instruction Group | Description | Examples |
| ----------------- | ----------- | -------- |
| Branch and control | These instructions are used to: • Follow subroutines • Go forward and backwards for conditional structures and loops • Make instructions conditional • Switch between ARM and Thumb states | B: Branch BX: Branch and exchange instruction set CBZ: Compare against zero and branch IT: If-then, makes up to four following instructions conditional (32-bit Thumb) |
| Data processing | Operate with GPRs, support data movement between registers and arithmetic operations |  ADD: Add MOV: Move data MUL: Multiply |
| Register load and store | Register load and store | Move data between registers and memory | LDR: Load register (1 byte) STRB: Store register (1 byte) SWP: Swap register and memory content |
| Multiple register load and store | Load or store multiple GPRs from or to memory | STM/LDM: Store and load multiple registers to and from memory PUSH/POP: Push and pop registers to and from the stack |
| Status register access | Move the content of a status register (CPSR or SPSR) to or from a GPR | MRS: Move the contents of the CPSR or SPSR to a GPR MSR; load specified fields of the CPSR or SPSR with an immediate value or another register's value |
| Coprocessor | Extend the ARM architecture; enable control of the system control coprocessor registers (CP15) | CDP/CDP2: Coprocessor data operations |

In order to interact with the OS, syscalls can be accessed using the Software Interrupt
(SWI) instruction, which was later renamed the Supervisor Call (SVC) instruction.

See the official ARM documentation to get the exact syntax for any instruction. Here is an
example of how it may look:

SVC{cond} #imm

The {cond} code in this case will be a condition code. There are several condition codes
supported by ARM, as follows:
+ EQ: Equal to
+ NE: Not equal to
+ CS/HS: Carry set or unsigned higher or both
+ CC/LO: Carry clear or unsigned lower
+ MI: Negative
+ PL: Positive or zero
+ VS: Overflow
+ VC: No overflow
+ HI: Unsigned higher
+ LS: Unsigned lower or both
+ GE: Signed greater than or equal to
+ LT: Signed less than
+ GT: Signed greater than
+ Signed less than or equal to
+ AL: Always (normally omitted)

An imm value stands for the immediate value.

### MIPS

MIPS: Microprocessor without Interlocked Pipelined Stages
+ developed by MIPS technolgies(formely MIPS computer systems)
+ First a 32-bit arch with 64-bit added later.
+ low power and heat consumption from taking advantage of "RISC ISA"
+ Often found in systems such as routers, gateways, and other IoT, even PS consoles
+ due to it's popularity, there's many malwares out there designed for it


As the architecture evolved, there were several versions of it, starting from MIPS I and
going up to V, and then several releases of the more recent MIPS32/MIPS64. MIPS64
remains backward-compatible with MIPS32. These base architectures can be
further supplemented with optional architectural extensions called Application Specific
Extension (ASE) and modules to improve performance for certain tasks that are generally
not used by the malicious code much. MicroMIPS32/64 are supersets of MIPS32 and
MIPS64 architectures respectively, with almost the same 32-bit instruction set and
additional 16-bit instructions to reduce the code size. They are used where code
compression is required, and are designed for microcontrollers and other small embedded
devices.

MIPS supports bi-endianness. The following registers are available:

+ 32 GPRs r0-r31, 32-bit size on MIPS32 and 64-bit size on MIPS64.
+ A special-purpose PC register that can be affected only indirectly by some instructions.
+ Two special-purpose registers to hold the results of integer multiplication and division (HI and LO). These registers and related instructions were removed from the base instruction set in the release of 6 and now exist in the Digital Signal Processor (DSP) module.

The reason behind 32 GPRs is simple, MIPS uses 5 bits to specify the register, so this way,
we can have a maximum of 2^5 = 32 different values. Two of the GPRs have a particular
purpose, as follows:

+ Register r0 (sometimes referred to as $0 or $zero) is a constant register and always stores zero, and provides read-only access. It can be used as a /dev/null analog to discard the output of some operation, or as a fast source of a zero value.
+ r31 (also known as $ra) stores the return address during the procedure call branch/jump and link instructions.

Other registers are generally used for particular purposes, as follows:

+ r1 (also known as $at): Assembler temporary—used when resolving pseudoinstructions
+ r2-r3 (also known as $v0 and $v1): Values—hold return function values
+ r4-r7 (also known as $a0-$a3): Arguments—used to deliver function arguments
+ r8-r15 (also known as $t0-$t7/$a4-$a7 and $t4-$t7): Temporaries—the first four can also be used to provide function arguments in N32 and N64 calling conventions (another O32 calling + convention uses only r4-r7 registers; subsequent arguments are passed on the stack)
+ r16-r23 (also known as $s0-$s7): Saved temporaries—preserved across function calls
+ r24-r25 (also known as $t8-$t9): Temporaries
+ r26-r27 (also known as $k0-$k1): Generally reserved for the OS kernel
+ r28 (also known as $gp): Global pointer—points to the global area (data segment)
+ r29 (also known as $sp): Stack pointer
+ r30 (also known as $s8 or $fp): Saved value/frame pointer—stores the original stack pointer (before the function was called).

MIPS also has the following co-processors available:
+ CP0: System control
+ CP1: FPU
+ CP2: Implementation-specific
+ CP3: FPU (has dedicated COP1X opcode type instructions)

#### The instruction set

The majority of the main instructions were introduced in MIPS I and II. MIPS III introduced
64-bit integers and addresses, and MIPS IV and V improved floating-point operations and
added a new set to boost the overall efficacy. Every instruction there has the same
length—32 bits (4 bytes), and any instruction starts with an opcode that takes 6 bits. The
three major instruction formats supported are R, I, and J:

| Instruction category | Syntax | Description |
| -------------------- | ------ | ----------- |
| R-type | Specifies three registers: an optional shift amount field (for shift and rotate instructions), and an optional function field (for control codes to differentiate between instructions sharing the same opcode) | These instructions are used when all the data values used are located in registers |
| I-type |Specifies two registers and an immediate value | This group is used when the instruction operates with a register and an immediate value, for example, the ones that involve memory operations to store the offset value | 
| J-type | Has a jump target address after the opcode that takes the remaining bits | They are used to affect the control flow |

For the FPU-related operations, the analogous FR and FI types exist.

Apart from this, several other less common formats exist, mainly coprocessors and
extension-related formats.

In the documentation, registers usually have the following suffixes:

+ Source (s)
+ Target (t)
+ Destination (d)

All instructions can be split into the following several groups depending on the
functionality type:

Control flow—mainly consists of conditional and unconditional jumps and branches:
+ JR: Jump register (J format)
+ BLTZ: Branch on less than zero (I format)

Memory access—load and store operations:
+ LB: Load byte (I format)
+ SW: Store word (I format)

ALU—covers various arithmetic operations:
+ ADDU: Add unsigned (R format)
+ XOR: Exclusive or (R format)
+ SLL: Shift left logical (R format)

OS interaction via exceptions interacts with the OS kernel:
+ SYSCALL: System call (custom format)
+ BREAK: Breakpoint (custom format)

Floating-point instructions will have similar names for the same types of operations in most
cases, for example, ADD.S. Some instructions are more unique such as Check for Equal
(C.EQ.D).

As we can see here and later, the same basic groups can be applied to virtually any
architecture, and the only difference will be in the implementation. Some common
operations may get their own instructions to benefit from optimizations and, in this way,
reduce the size of the code and improve the performance.

As the MIPS instruction set is pretty minimalistic, the assembler macros called pseudoinstructions
also exist. Here are some of the most commonly used:

+ ABS: Absolute value—translates to a combination of ADDU, BGEZ, and SUB
+ BLT: Branch on less than—translates to a combination of SLT and BNE
+ BGT/BGE/BLE: Similar to BLT
+ LI/LA: Load immediate/address—translates to a combination of LUI and ORI or
+ ADDIU for a 16-bit LI
+ MOVE: Moves the content of one register into another—translates to ADD/ADDIU
+ with a zero value
+ NOP: No operation—translates to SLL with zero values
+ NOT: Logical NOT—translates to NOR

### PowerPC
PowerPC stands for Performance Optimization With Enhanced RISC, Performance
Computing and sometimes spelled as PPC.
+ Created in early 1990's by the alliance of apple, IBM and motorola
+ originally intented to be used in PC's and used in Apple PowerBooks and iMacs up to 2006.
+ also used in PS3, XBOX360, Wii consoles as well as IBM servers and multiple embedded devices for cars, planes and even teh ASIMO robot.
+ admin responsibilities transferred to "Power.org" with IBM and Freescale staying as members and then later seperated from Motorola and later aquired by NXP Semiconductors and others.
+ OpenPOWER is a newer initiative by IBM, Google, NVIDEA, Mellanox and Tyan to work on future the technology.
+ PowerPC was mainly based on "IBM POWER ISA" and later a unified Power ISA was released which combined POWER and PowerPC into a single ISA that is currently being used in multiple products under the "Power Architecture" umbrella.
+ many malwares families exist with payload for this arch


The Power ISA is divided into several categories; each category can be found in a certain
part of the specification or book. CPUs implement a set of these categories depending on
their class; only the base category is an obligatory one.

+ Base: Covered in Book I (Power ISA User Instruction Set Architecture) and Book II (Power ISA Virtual Environment Architecture)
+ Server: Covered in Book III-S (Power ISA Operating Environment Architecture – Server Environment)
+ Embedded: Book III-E (Power ISA Operating Environment Architecture – Embedded Environment)

There are many more granular categories covering aspects such as floating-point operations
and caching for certain instructions.

Another book, Book VLE (Power ISA Operating Environment Architecture – Variable Length
Encoding (VLE) Instructions Architecture), defines alternative instructions and definitions
intended to increase the density of the code by using 16-bit instructions as opposed to the
more common 32-bit ones.

Power ISA version 3 consists of three books with the same names as Books I to III of
the previous standard, without distinctions between environments.

The processor starts in the big-endian mode but can switch by changing a bit in the MSR
(Machine State Register), so that bi-endianness is supported.


#### REGISTERS

There are many sets of registers documented in Power ISA, mainly grouped around either
an associated facility or a category. Here is a basic summary of the most commonly used ones:

32 GPRs for integer operations, generally used by their number only (64-bit)
64 Vector Scalar Registers (VSRs) for vector operations and floating-point
operations:

+ 32 Vector Registers (VRs) as part of the VSRs for vector operations (128-bit)
+ 32 FPRs as part of the VSRs for floating-point operations (64-bit)

Special purpose fixed-point facility registers, such as the following:
+ Fixed-point exception register (XER)—contains multiple status bits (64-bit)

Branch facility registers:
+ Condition Register (CR)—consists of 8 4-bit fields, CR0-CR7, involving things like control flow and comparison (32-bit)
+ Link Register (LR)—provides the branch target address (64-bit)
+ Count Register (CTR)—holds a loop count (64-bit)
+ Target Access Register (TAR)—specifies branch target address (64-bit)

Timer facility registers:
+ Time Base (TB)—is incremented periodically with the defined frequency (64-bit)

Other special purpose registers from a particular category, including the following:
+ Accumulator (ACC) (64-bit)—the Signal Processing Engine (SPE) category

Generally, functions can pass all arguments in registers for non-recursive calls; additional
arguments are passed on the stack.

#### Instruction set

Most of the instructions are 32-bit size, only the Variable-Length Encoding (VLE) group
is smaller in order to provide a higher code density for embedded applications. All
instructions are split into the following three categories:

+ Defined: All of the instructions are defined in the Power ISA books.
+ Illegal: Available for future extensions of the Power ISA. An attempt to execute them will invoke the illegal instruction error handler.
+ Reserved: Allocated to specific purposes that are outside the scope of the Power
+ ISA. An attempt to execute them will either perform an implemented action or invoke the illegal instruction error handler if the implementation is not available.


Bits 0 to 5 always specify the opcode, and many instructions also have an extended opcode. A large number of instruction formats are supported; here are some examples:

+ I-FORM \[OPCD+LI+AA+LK]
+ B-FORM \[OPCD+BO+BI+BD+AA+LK]

Each instruction field has its own abbreviation and meaning; it makes sense to consult the
official Power ISA document to get a full list of them and their corresponding formats. In
the case of the previously mentioned I-FORM, they are as follows:
+ OPCD: Opcode
+ LI: Immediate field used to specify a 24-bit signed two's complement integer
+ AA: Absolute address bit
+ LK: Link bit affecting the link register

Instructions are also split into groups according to the associated facility and category,
making them very similar to registers:

Branch instructions:
+ b/ba/bl/bla: Branch
+ bc/bca/bcl/bcla: Branch conditional
+ sc: System call

Fixed-point instructions:
+ lbz: Load byte and zero
+ stb: Store byte
+ addi: Add immediate
+ ori: Or immediate

Floating-point instructions:
+ fmr: Floating move register
+ lfs: Load floating-point single
+ stfd: Store floating-point double

SPE instructions:
+ brinc: Bit-reversed increment

### SuperH

SuperH(or just SH) is a RISC ISA developed by Hitachi and have gone torugh several iterations starting from SH-1 up to the current one which are SH-5.

SH-5 has two modes of operations, one of which is identical to the user-mode instructions of SH-4 and the other mode, "SHmedia", which is quite different.

Each family has it's own targeted market as follows:

+ SH-1: Home appliances
+ SH-2: Car controllers and video game consoles such as Sega Saturn
+ SH-3: Mobile applications such as car navigators
+ SH-4: Car multimedia terminals and video game consoles such as Sega Dreamcast
+ SH-5: High-end multimedia applications

Microcontrollers and CPU's implementing it are being produced by Renesas Electronics which is a joint venture between Hitachi and Mitsubishi Semiconductor groups. 

IoT malware mainly targets the SH-4 based systems

#### Registers

In terms of registers, SH-4 offers the following:

16 general registers R0-R15 (32-bit)
7 control registers (32-bit):

+ Global Base Register (GBR)
+ Status Register (SR)
+ Saved Status Register (SSR)
+ Saved Program Counter (SPC)
+ Vector Base Counter (VBR)
+ Saved General Register 15 (SGR)
+ Debug Base Register (DBR) (only from the privileged mode)

4 system registers (32-bit):

+ MACH/MACL: Multiply-and-accumulate registers
+ PR: Procedure register
+ PC: Program counter
+ FPSCR: Floating-point status/control register

32 FPU registers FR0-FR15 (also known as DR0/2/4/... or FV0/4/...) and XF0-XF15 (also known as XD0/2/4/... or XMTRX); two banks of either 16 singleprecision (32-bit) or eight double-precision (64-bit) FPRs and FPUL (floatingpoint communication register) (32-bit).

Usually, R4-R7 are used to pass arguments to a function with the result returned in R0. R8-
R13 are saved across multiple function calls. R14 serves as the frame pointer and R15 as a
stack pointer.

Regarding the data formats, in SH-4, a word takes 16 bits, a long word takes 32 bits, and a
quad word takes 64 bits.

Two processor modes are supported: user mode and privileged mode. SH-4
generally operates in the user mode and switches to the privileged mode in case of an
exception or an interrupt.

#### Instruction Set

The SH-4 features instruction set that is upward-compatible with the SH-1, SH-2, and SH-3
families. It uses 16-bit fixed length instructions in order to reduce the program code
size. Except for BF and BT, all branch instructions and the RTE (return from exception
instruction) implement so-called delayed branches, where the instruction following the
branch is executed before the branch destination instruction.

All instructions are split into the following categories (with some examples):

Fixed-point transfer instructions:
+ MOV: Move data (or particular data types specified)
+ SWAP: Swap register halves

Arithmetic operation instructions:
+ SUB: Subtract binary numbers
+ CMP/EQ: Compare conditionally (in this case on equal to)

Logic operation instructions:
+ AND: AND logical
+ XOR: Exclusive OR logical

Shift instructions:
+ ROTL: Rotate left
+ SHLL: Shift logical left

Branch instructions:
+ BF: Branch if false
+ JMP: Jump (unconditional branch)

System control instructions:
+ LDC: Load to control register
+ STS: Store system register

Floating-point single-precision instructions:
+ FMOV: Floating-point move

Floating-point double-precision instructions:
+ FABS: Floating-point absolute value

Floating-point control instructions:
+ LDS: Load to FPU system register

Floating-point graphics acceleration instructions:
+ FIPR: Floating-point inner product

### SPARC

Scalable Processor Architecture (SPARC) is a RISC ISA that was originally developed by
Sun Microsystems (now part of the Oracle corporation). The first implementation was used
in Sun's own workstation and server systems. Later, it was licensed to multiple other
manufacturers, one of them being Fujitsu. As Oracle terminated SPARC Design in 2017, all
future development continued with Fujitsu as the main provider of SPARC servers.

Several fully open source implementations of SPARC architecture exist. Multiple operating
systems are currently supporting it, including Oracle Solaris, Linux, and BSD systems, and
multiple IoT malware families have dedicated modules for it as well.

#### Registers

According to the Oracle SPARC Architecture documentation, the particular
implementation may contain between 72 and 640 general-purpose 64-bit R registers.
However, only 31/32 GPRs are immediately visible at any one time; 8 are global
registers, R\[0] to R\[7] (also known as g0-g7), with the first register, g0, hardwired to
0; and 24 are associated with the following register windows:

+ Eight in registers in\[0]-in\[7] (R\[24]-R\[31]): For passing arguments and returning results
+ Eight local registers local\[0]-local\[7] (R\[16]-R\[23]): For retaining local variables
+ Eight out registers out\[0]-out\[7] (R\[8]-R\[15]): For passing arguments and returning results

The CALL instruction writes its own address into the out\[7] (R\[15]) register.

In order to pass arguments to the function, they must be placed in the out registers and,
when the function gets control, it will access them in its in registers. Additional arguments
can be provided through the stack. The result is placed to the first in register, which then
becomes the first out register when the function returns. The SAVE and RESTORE
instructions are used in this switch to allocate a new register window and later restore the
previous one, respectively.

SPARC also has 32 single-precision FPRs (32-bit), 32 double-precision FPRs (64-bit), and 16
quad-precision FPRs (128- bit), some of which overlap.

Apart from that, there are many other registers that serve specific purposes, including the
following:

FPRS: Contains the FPU mode and status information
Ancillary state registers (ASR 0, ASR 2-6, ASR 19-22, and ASR 24-28 are not reserved): Serve multiple purposes, including the following:
+ ASR 2: Condition Codes Register (CCR)
+ ASR 5: PC
+ ASR 6: FPRS
+ ASR 19: General Status Register (GSR)

Register-Window PR state registers (PR 9-14): Determine the state of the register windows including the following:
+ PR 9: Current Window Pointer (CWP)
+ PR 14: Window State (WSTATE)

Non-register-Window PR state registers (PR 0-3, PR 5-8 and PR 16): Visible only to software running in the privileged mode

32-bit SPARC uses big-endianness, while 64-bit SPARC uses big-endian instructions but can
access data in any order. SPARC also uses a notion of traps that implement a transfer of
control to privileged software using a dedicated table that may contain the first 8
instructions (32 for some frequently used traps) of each trap handler. The base address of
the table is set by software in a Trap Base Address (TBA) register.


#### Instruction set

The instruction from the memory location, which is specified by the PC, is fetched and
executed, and then new values are assigned to the PC and the Next Program Counter
(NPC), which is a pseudo-register.

Detailed instruction formats can be found in the individual instruction descriptions.

Here are the basic categories of instructions supported, with examples:

Memory access:
+ LDUB: Load unsigned byte
+ ST: Store

Arithmetic/logical/shift integers:
+ ADD: Add
+ SLL: Shift left logical

Control transfer:
+ BE: Branch on equal
+ JMPL: Jump and link
+ CALL: Call and link
+ RETURN: Return from the function

State register access:
+ WRCCR: Write CCR

Floating-point operations:
+ FOR: Logical OR for F registers

Conditional move:
MOVcc: Move if the condition is True for the selected condition code (cc)

Register window management:
+ SAVE: Save caller's window
+ FLUSHW: Flush register windows

Single Instruction Multiple Data (SIMD) instructions:
+ FPSUB: Partitioned integer subtraction for F registers

--------

#