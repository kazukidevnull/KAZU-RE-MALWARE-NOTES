# Malware Analysis Notes overview
 
 This Directory is for various notes regarding dealing with malware and below you will find various notes in relation to doing Malware Analysis and such

 This file will start with all the main category and topics listed at the start for easy overview and then go into details about each category past it which will contain details about the various things listed at the start, 
 
 the overview part also function as a way for me to quickly note down things i remember/come across to write more details about later, so there will be a lot more in the overview then there's information about them.

------------
## Index:

--Packers:
--


----------
## DETAILS:

### Packers

There many kinds of packers, some are made for benign purposes while others are made specially for hiding something and make analysis of the file harder

one of the most commonly popular packers are 
+ UPX: The most common used packers out there and the most often encountered type of packer since it's open source, it can be unpacked using cmd
+ ASPack: This is a commonly used packer which has a free and a premium version. The same company that provides ASPack also provides protectors such as ASProtect.



### Indentifying Packers

there are many way to identify if file is packaged and by what, some are very easy and some are more involved, on the easier side theres tools such as "PEiD" or CFF explorer to check the PE of the file as all packers have their own characteristics which help ID them:
+ UPX Packer: renames as sections as "UPX1", "UPX2" and so forth
+ ASPack: Names the last section ".aspack"

sometimes you need to look a little harder to find out what packer was used, An unpacked PE file contains sections such as .text or .code, .data, .idata, .rsrc, and .reloc, while packed files can contain specific section names, such as UPX0, .aspack, .stub, and so on, if you find a section name with unknown name, then google it may help.
  
most packers also compress the file sections which include the code & data section, including the import table and so forth, and then add a new section at the end which contains the code to unpack everything again, due to all this, execution is normally started from the last section which is a clear indication of decryption is done, other signs include: 
+  The entry point is not pointing to the first section (it would mostly be pointing to one of the last two sections) and this section's memory permission is EXECUTE (in the section's characteristics)
+ The first section's memory permission will be mostly READWRITE

Many viruses that unfect executables have similar attributes

For most applications, the import table is full of APIs from system libraries, as well as thirdparty libraries; however, in most of the packed PE files, the import table will be quite small, and will include a few APIs from known libraries. This is enough to unpack the file.

Only one API from each library of the PE file would be used after being unpacked. The reason for this is that most of the packers load the import table manually after unpacking the PE file

Note: packers such as IPC is often modified, so often the UPX unpacking tool will fail to unpack.

### Dealing with Packers/encrypted blocks

#### The automatic way

Method 1:

the official unpacking process

some packers such as UPX are "self-extracting" packages, since they are made to just make it easier to move the file around, they often include a way to unpack them easily,

Event in the cases of commercially used protectors which are designed to protect against RE and detection, if the tool is used illegally, it's often possible to contact the provider of the protector software and get them to unlock it.

Method 2:

Using OllyScript with OllyDbg

There is an OllyDbg plugin called OllyScript that can help automate the unpacking process. It does this by scripting OllyDbg actions, such as setting a breakpoint, continuing execution, and pointing the EIP register to a different place or modifying some bytes. 

Nowadays, OllyScript is not widely used, but is nice to be aware of it.

Method 3 

Using "generic unpacker" such as "QuickUnpack"

Generic unpackers have been created to automate manual unpacking or unpack specific packers

They are more generic and can work with multiple packers, even if the packers were not designed to unpack their files: however, malware can easily escape from these tools, which may lead to the execution of the malware on the user's machine. Because of this, you should always use these tools on a virtual machine or in a safe environment.

Method 4:

Using Emulation tool like libemu and the Pokas x86 Emulator to run the code without actually running it

one way to do this using "Pokas x86" for UPX would be:

```

from pySRDF import * emu = Emulator("upx.exe") x = emu.SetBp("__isdirty(eip)") #which set bp on Execute on modified data emu.Run() # OR emu.Run("ins.log") to log all running instructions emu.Dump("upx_unpacked.exe",DUMP_FIXIMPORTTABLE) #DUMP_FIXIMPORTTABLE create new import table for new API print "File Unpacked Successfully\n\nThe Disassembled Code\n----------------"

```

Method 5

Doing Memory dumps

The last technique we will mention is incorporating memory dumps. This technique is widely used, as it's one of the easiest for most packers and protectors to use (especially if they have anti-debugging techniques), as it basically involves executing the malware and taking a memory snapshot of its process and every process it injects code into.

This technique is very beneficial for static analysis, as well for static signature scanning; however, the memory dump that is produced is different from the original sample and can't be executed. The addresses and the import table need to be fixed before any further dynamic analysis is possible.

many RE people prefer to just dump the memory and hope to be lucky, but as mentioned, this has many disadvantages, including also:  

+ It is possible that the unpacked sample will already be mapped by sections and that the import table will already have been populated, so the engineer will have to change the physical addresses of each section to be equal to the virtual ones, restore imports, and maybe even handle relocs in order to make them executable again. The hash of this sample will be different from the original one.
+ The original loader may unpack the sample to allocated memory, inject it somewhere else, and free the memory so that it won't be a part of the full dump.
+ It is very easy to miss some modules; for example, the original loader may unpack only a sample for a 32- or 64-bit platform.

Since this technique doesn't provide a clean sample, and because of the limitations of the previous automated techniques described, it is recommended doing a manual unpacking over using memory dumps.



#### The Manual Way

METHOD 1

Manual unpacking using OllyDbg:

First enable DEP(Data Execution Prevention) in windows to prevent execution of processes even if non-critial ones

then set memory breakpoint on execution by changing the sections permission by going to memory window ("view > memory") and then right click first memory section of the file like "UPX0" for UPX and and slect "Read/Write" under "set access".

sometimes malwares tries to modify itself to change access back to "full access" by modfying the permissions using "VirtualProtect"s API for instance.

by setting a breakpoint on the API such as "virtualProtect" you can break if the program tries to change permissions, to find it, you can right click on the CPU disassemble area and select "Go to > Expression"(or just hit CTRL-G) and search for the API

once you run teh program it should break on OEP, but sometimes some packers modifies the first couple of bytes of the first section with instructions such as "ret", "jmp", "call", but after a few iterations the program will break, which occur after full decryption/decompresssion.

METHOD 2

Call stack backtracing

Using the call stack to captured a unpacked package is one of the ways that can be fast and efficient and works most of the time.

We archive this by setting breakpoints that we are sure will make the debugged process to break in the middle of executing the decrypted code which lets us then backtrack to the beginning of the decrypted code and then declare that as OEP.

to be able to do this properly you should optimally have knowledge of what API's is used to execute at some point, these will normally be gained trough behaviour analysis or a sandbox report, but you can also just guess using some of the common API used such as 

+ GetModuleFileNameA
+ GetCommandLine
+ CreateFileA
+ VirtualAlloc
+ HeapAlloc
+ memset

once you figure out what API to look for you add a breakpoint to them all, except the ones that could be used by the unpacking stub, and then execute the program until the execution breaks

then just follow the call stack until you find the first return address, then follow the return address on the disassembled section in the CPU viewer, once you have reached the first call in the unpacked section, then you only need to to find the OEP by looking a bit further up,

WARNING: this method, for obvious reasons, can lead to the exxecution of the file you are drying to reverse

METHOD 3

monitoring memory allocated spaces for unpacked code

if time is limited or have a lot of samples, then this method may be suitable as it won't go until the details of how the sample is actually stored.

Often, malwares(and non malwares) often allocate a big block of memory to store the unpacked/decrypted file, although, this is not always the case.

There exist numerous API's in windows to allocate memory in user mode, but the most common ones are:

+ VirtualAlloc/VirtualAllocEx
+ LocalAlloc
+ GlobalAlloc
+ HeapAlloc

for kernal mode, there's following API which pretty much does the same as the ones listed above:

+ RtlAllocateHeap
+ ZwAllocateVirtualMemory
+ ExAllocatePoolWithTag

Also, if the sample are in C then looking for the "malloc/calloc" function will be a logical thing to do, for C++ the "new" operator is also worth monitoring.

You can set breakpoint on execution as long as you break at the entry point or beginning of the TLS routine, while it's usually file setting breakpoint at the first function instruction, there's still the possibility of it getting "hooked" and get it's first bytes replaced with custom code for anti-RE reasons, in this case, setting the breakpoint at the last instruction may work better 

after this is done you can then resume execution and monitoring the allocated block size, as long as it's big enough, you can put a breakpoint on write access to intercept it when it starts getting written to, if the functions are called too many times, it's best to place a conditional breakpoint which only break over a certain size.

if the block is still encrypted after this, we can keep a breakpoint on writes and wait until the decryption routine starts processing it, after last byte is decrypted/unpacked we can dump the memory to disk.

Other API functions that can be used in the same approach include the following:

+VirtualProtect: Malware authors can use this in order to make the memory block storing the unpacked sample executable
+WriteProcessMemory: Often used in order to inject the unpacked payload, either to some other process or to itself

In normal cases, when the file is decrypted/unpacked, it usually have the correct "MZ-PE" file, which can of course be analysed using other PE-tools, but this is not always the case, 

sometimes the decrypted block is a corrupt executable which depends on the original packer to function correctly 

or, the packer decrypts the sample is decrypted section by section and loads each of them one at a time instead of all at once, this can be handled in following ways:

+ Dump sections as long as they become available and concatenate them later
+ Modify the decryption routine to process the whole sample at once
+ Write a script that decrypts the whole encrypted block


Also, if the decrypted/unpacked programs fail to run properly, it can very much be the case it either need some parameters to run or be  loaded in a specific way, Anti-RE functions may be the reason as well which need to be bypassed, in which case, set a breakpoint just before the sample terminates (such at "ExitProcess", "TerminateProcess" or the more fancy "PostQuitMessage") and look for what is responsible for ti

Since it's quicker, some prefer avoid going into the sub-routines of when manually going trough the functions and only do such when needed.

Method 4:

in-place unpacking

while not common, it's possible to decrypt/unpack in the same section as the encrypted/packed sample, this section should also have write permission.

To find the encrypted block, look for places with big encrypted block, which usually have high entropy, then once you found it, find the exact place where it will start to read and set a breakpoint on read and/or write on it, the first couple of butes of the block may sometimes also have other metadata worth looking for that may have checksums/hashes be used to verify the decryption and such.

run the program and wait for break.

set a breakpoint on execution or the last written byte of the encrypted block and then dump it.

This method can also be used for samples that relies on allocating memory.

Method 5:

Stack Restoration-based

This method is usually quicker then the last two method mentioned, but is very much not a reliable method and is mostly only suitable for quick check before using other methods, i considered not including this for this reason, but is good to be aware of it.

The idea here is that some packers keep the stack in order and transfer control to the unpacked sample when it has the same stack level that they started with. What that means is that it will access the value located at the address that was originally pointed by the frame pointer register (ebp/rbp), minus one value of a size of the address length for the selected architecture (for example, a 4-byte DWORD for a 32-bit platform) just before transferring control to the unpacked code, even when using the jmp instruction

In this case, it is possible to set a breakpoint on access to the [ebp-4] value while staying at the entry point of the sample and then executing it so that the breakpoint will hopefully trigger just before transferring control to the unpacked code. Often, this happens when the packer restores the registers to the original values—for example, by using the popad instruction.

Obviously, this may never happen, depending on the implementation of the unpacking code, and there may be other situations where this does happen (for example, when there are multiple garbage calls before starting the actual unpacking process).

### Process dumping:

There's various tools available to dump processes such as 

+ ollyDump: ollyDbg plugin which unload the PE file from memory to the needed format.
+ PETools:let's you dump a particular memory region which ollyDump don't let you do.
+ Lord PE: let's you dump a particular memory region which ollyDump don't let you do.

#### Using each tool:

ollyDump:

Set the OEP (which you found after from the unpacking/decrypting process done earlier), then optionally select "rebuild import" if you want ollDump to fix the import table, or uncheck it to use other tools after you dumped to file.

PETools:

Lord PE:

### Fixing the import table

when the PE file gets loaded in the process memory or the unpacker stub loads the import table, the loader goes through the Import Table header from the Data Directory and populates it with the actual addresses of API functions from DLLs that are available on the machine

After this, these API addresses are used to acccess these APIs throughout the application code, usually by using "call" and "jmp" instructions

To unload the import table, we need to find this list of API addresses, find which API each address represents (we need to go through each library list of addresses and their corresponding API names for this), and then replace each of these addresses with either an offset pointing to the API name string or an ordinal value. If we don't find the API names in the file, we may need to create a new section that we can add these API names to and use them to restore the Import Table.

Luckliy, tools such as Import Reconstructor(ImpREC) can helo do a lot of the hard work.

To fix the import table, you need to follow these steps:
1. Dump the process or any library you want to dump using, for example, OllyDump (and uncheck the Rebuild Import checkbox) or any other tool of preference
2. Open ImpREC and choose the process you are currently debugging.
3. Now, set the OEP value to the correct value and click on IAT AutoSearch.
4. After that, click on Get Imports and delete any rows with valid: NO from the Imported Functions Found section.
5. Click on the Fix Dump button and then select the previously dumped file. Now, you will have a working, unpacked PE file. You can load it in PEiD or any other PE explorer application to check whether it's working. For a 64-bit Windows system, Scylla or CHimpREC can be used instead.


## Identifying encryption algorithms and functions

Nowadays many good and bad programs use encryptions both as a Anti-RE and security measure to avoid tamperings, in this section we will go more into how we can identify encryptions and functions.

Most encryption algorithms that are used by malware consist of basic mathematical and logical instructions—that is, xor, add, sub, rol, and ror. These instructions are reversible, and you don't lose data while encrypting with them compared to shl, shr, where it is possible to lose some bits from the left and right. This also happens with and, or, which can lead to the loss of data when using or with 1 or and with 0.


### Types of encryptions: 

Symmetric algorithms:
These types of algorithms use the same key for encryption and decryption. It's a secret key that's shared by both sides, alogrithms that is symmentric are:

+ DES:
+ AES:
+ RSA:




Asymmetric algorithms:



Asymmetric algorithms: In this algorithm, two keys are used. One is used for encryption and the other is used for decryption. These two keys are called the public key and the private key. One key is shared publicly (public key), while the other one is kept in secret (private key).

### Basic encryptions
Basic encryptions:
+ Simple static encryption: This use basic operations such as "xor", "add", "rol"
+ Running key encryption:
+ Substitutional key encryption: substitutes bytes with another or a value with anohter value, 


To ID a encryption there's four main things to keep in mind, those are:

+ Sequential data read: encryption have to read data from memory one at a time from a array and not a fixed value,
+ Encrypting the value: data and memory copiers can easily look similar to a encryption loop, so look for actual encryptions happening.
+ Sequention data write: easy to miss as well, but if the function writes to a fixed address, it's possible just generating a checksum of the data for integrity purposes, commonly used to check for INT3 Breakpoints.
+ Loop: if the variable used in the the sequential read/write is not getting modified between iterations, it is possible not a encryption function as the variable used as loop index is the same used for seq read/write and changes each iteration. 

Note: these will usually be easy to spot in smaller encryption loop, but harder as the encryption get more complicated

#### Identifying RC4 encryption

RC4 is one of the most common encryptions used by malwares due to it's simple but strong algorithms, but there's no WinAPI for it, so it's harder to identify.

RC4 is a symmetric algorithm with one secret key at max 256 bytes, the algorithm is made up of two parts, a "key-scheduling algorithm"(KSA) and a "pseudo-random generation algorithm"(PRGA), which are both detailed further below.

+ Key-scheduling algorithm: the KSDA creates a array of 256 bytes from the secret key, which is just a bigger version of the key. this array is used to encrypt and decrypt the data and consist of following parts:
    
    Creates an array with values from 0 to 256 sequentially:

    ```
    for i from 0 to 255
         S[i] := i
    endfor
    ```

    It swaps bytes based on the key—this generates an index number, j, based on the secret key:

    ```
    for i from 0 to 255
         j := (j + S[i] + key[i mod keylength]) mod 256
         swap values of S[i] and S[j]
    endfor

    ```

    Once this initiation part for the key is done, the decryption algorithm starts. In most cases, the KSA part is written in a separate function that takes only the secret key as an argument, without the data that needs to be encrypted or decrypted.

+ Pseudo-random generation algorithm: The pseudo-random generation part of the algorithm just generates pseudo-random values (again, based on swapping bytes, like we did for the key), but also performs a XOR operation with the generated value and a byte from the data:

    ```
    i := 0
    j := 0
    while GeneratingOutput:
        i := (i + 1) mod 256
        j := (j + S[i]) mod 256
        swap values of S[i] and S[j]
        K := S[(S[i] + S[j]) mod 256]
        Data[i] = Data[i] xor K
    endwhile

    ```


#### Identifying RC4 ecryption in programs

Some key points to detect RC4 encryption:

+ Generation of 256 bytes arrays: This is usually easy to find as it's quite unique for a typical RC4.
+ a lot of swapping: a lot of swapping of functions or code happens and, KSA and PRGA part of the algorithms is good sign ot's RC4. 
+ The actual algorithm is XOR: The algorithm is basically a "xor" alogorithm and all the swapping is done on key with the only change that affect data done trough "xor"
+ Encryption and decryption similarity: The encryption and decryption functions are the same, which mean you can decrypt the encrypted data using the same key.

### Other Standard symmetric and asymmetric encryptions

in addition to RC4, many malware make use of symmetric encryption such as DES and AES or Asymmetric ones such as RSA, althought, they rarely implement or include the the alogorithm inside their malware but relies on WinAPI's or third-party libraries such as OpenSSL.

all these are more complicated then RC4 and thus harder to understand in details, luckily, that is not required to be able to identify their algorithm, the way they are used or the encryption/decryption key and data,

Since most malwares relies on WinAPI to do their encryptions, it's easier to identify programs that does such by looking for the API called from Advapi.dll, some of the common ones are:
+ CryptAcquireContext
+ CryptCreateHash
+ CryptHashData
+ CryptEncrypt
+ CryptDecrypt
+ CryptImportKey
+ CryptDestroyKey
+ CryptDestroyHash
+ CryptReleaseContext

#### En/decryption process and Identifying alogoritms

in this part we will look at the steps malware goes trough to encrypt/decrypt data and how to identify which algorithm is used:

phase 1 - initilazation and connection to the cryptographic service provider (CSP):

Windows have a library for various encryptions (such as DES, Triple DES, RC2, RC4, RSA and AES) which is named "cryptographic service provider" (CSP) and is used by most malwares(and other programs) for their encryption, to use any of them, the "CryptAcquireContext" API are used followed by the algorithm selected, such as `CryptAcquireContext(&hProv,NULL,MS_STRONG_PROV,PROV_RSA_FULL,0);`

The provider can tell a lot about the algorithm that can be used for encryption and most common values used by malwares

+ PROV_RSA_FULL: This provides access to DES, Triple DES, RC2, and RC4 for encryption, as well as RSA for key exchange and signatures
+ PROV_RSA_AES: This is used for AES, RC2, and RC4 encryption (again, together with RSA)

all the supported providers on the system can be found at the following location:
+ HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Cryptography\Defaults\Provider


Phase 2 - Key preparations:

there's two ways to prepare a encryption key and the encryption key are usually a fixed value such as 112, 128 bits, etc.

first way are either trough plain text key which they hash to MD5, SHA128, SHA256, etc using:
+ CryptCreateHash(hProv,CALG_MD5,0,0,&hHash);
+ CryptHashData(hHash,secretkey,secretkeylen,0);

Then, they create a session key from this hash using `CryptDeriveKey`,

for example, `CryptDeriveKey(hProv,CALG_3DES,hHash,0,&hKey);`

From here, they can easily identify the algorithm from the second argument value that's provided to this API. The most common algorithms/values are as follows:

+ CALG_DES = 0x00006601,// DES encryption algorithm.
+ CALG_3DES = 0x00006603,// Triple DES encryption algorithm.
+ CALG_AES = 0x00006611,// Advanced Encryption Standard (AES).
+ ALG_RC4 = 0x00006801,// RC4 stream encryption algorithm.
+ CALG_RSA_KEYX = 0x0000a400,// RSA public key exchange algorithm.

Some malware authors however use a KEYBLOB, which includes their key, with CryptImportKey. A KEYBLOB is a simple structure that contains the key type, the algorithm that was used, and the secret key for encryption. The structure of a KEYBLOB is as follows:

```
typedef struct KEYBLOB {
    BYTE bType;
    BYTE bVersion;
    WORD reserved;
    ALG_ID aiKeyAlg;
    DWORD KEYLEN;
   BYTE[] KEY;
}

```

The bType phrase represents the type of this key. The most common types are as follows:

+ PLAINTEXTKEYBLOB (0x8): States a plain text key for a symmetric algorithm, such as DES, 3DES, or AES
+ PRIVATEKEYBLOB (0x7): States that this key is the private key of an asymmetric algorithm
+ PUBLICKEYBLOB (0x6): States that this key is the public key of an asymmetric algorithm

The aiKeyAlg phrase includes the type of the algorithm as the second argument of CryptDeriveKey. Some examples of this KEYBLOB are as follows:

```
BYTE DesKeyBlob[] = {
  0x08,0x02,0x00,0x00,0x01,0x66,0x00,0x00, // BLOB header
  0x08,0x00,0x00,0x00, // key length, in bytes
  0xf1,0x0e,0x25,0x7c,0x6b,0xce,0x0d,0x34 // DES key with parity
};
```

As you can see, the first byte (bType) shows us that it's a PLAINTEXTKEYBLOB, while the algorithm (0x01,0x66) represents CALG_DES (0x6601).

Another example of this is as follows:

```
BYTE rsa_public_key[] = {
0x06, 0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00,
0x52, 0x53, 0x41, 0x31, 0x00, 0x08, 0x00, 0x00,
...
}

```

This represents a PUBLICKEYBLOB (0x6), while the algorithm represents CALG_RSA_KEYX (0xa400). After that, they are loaded via CryptImportKey:

```
CryptImportKey(akey->prov, (BYTE *) &key_blob, sizeof(key_blob), 0, 0, &akey->ckey)
```
Phase 3 - En/Decryption of data

Now that the key is ready, the malware uses CryptEncrypt or CryptDecrypt to encrypt or decrypt the data. With these APIs, you can identify the start of the encrypted blob (or the blob to be encrypted). These APIs are used like this:
+ CryptEncrypt(hKey,NULL,1,0,cyphertext,ctlen,sz);
+ CryptDecrypt(hKey,NULL,1,0,plaintext,&ctlen);

Phase 4 - Freeing up memory

This is the last step, where we free the memory and all the handles that have been used by
using the `CryptDestroyKey`, `CryptDestroyHash`, and `CryptReleaseContext` APIs.

## Cryptography API next generation (CNG)

Microsoft have also released a new set of encryption algorithm called "Cryptography API next generation" which is still not widely used by malwares but are a lot easier to understand and gain information from, the steps for using them is as follows:

1. Initialize the algorithm provider: 

    In this step, you can identify the exact algorithm (check MSDN for the list of supported algorithms):

    ```
    BCryptOpenAlgorithmProvider(&hAesAlg, BCRYPT_AES_ALGORITHM, NULL, 0)
    ```

2. Prepare the key: 

    This is different from preparing a key in symmetric and asymmetric algorithms. This API may use an imported key or generate a key. This can help you extract the secret key that's used for encryption, like so:

    ```
    BCryptGenerateSymmetricKey(hAesAlg, &hKey, pbKeyObject, cbKeyObject, (PBYTE)SecretKey, sizeof(SecretKey), 0)
    ```
3. Encrypt or decrypt data:

    In this step, you can easily identify the start of the data blob to be encrypted (or decrypted):

    ```
    BCryptEncrypt(hKey, pbPlainText, cbPlainText, NULL, pbIV, cbBlockLen, NULL, 0, &cbCipherText, BCRYPT_BLOCK_PADDING)
    ```

4. Cleanup:

    This is the last step, and uses APIs such as `BCryptCloseAlgorithmProvider`, `BCryptDestroyKey`, and `HeapFree` to clean up the data.


    RE-READ OF PAGE 135-139 OF "MASTERING MALWARE ANALYSIS" NEEDED



## String search detection for simple algorithms



### X-RAYING

This method was first introduced by patter ferrie in the "PRINCIPLES AND PRACTISE OF X-RAYING article in VB2004" and is a method used by AV and other static signature tools to detect samples with signatures even if they are encrypted and without knowing the key, 

This method relies on access to some decrypted data already to be able to decrypt the rest of the data, it basically relies on knowing the words beforehand that you are looking for and search for the first few bytes of the plaintext you are looking for, one way to use this is to detect program hiding inside a program by search for what is common to appear in the PE head of a program like so(using xor encryption):


```
for i in ciphertext:
    key = ciphertext[i:i+4] xor "This"
    if decrypt(ciphertext[i:<length of plaintext>], key) == " program
cannot run in DOS mode":
    we found it!!!
  else:
    continue searching

```

This works even if you don't know the file  offset of plain text or multiple layers are used.

For other simple encryption algorithms, you only need a longer plain text. This breaks through all the encryption layers, including the sliding key, substitutional encryption algorithms, and so on.

Recommended tool:

XORSearch: created by Didier Stevens and searches inside ciphertext by using a given plain text sample to search for, it also covers other algorithms then "xor" such as bitshifting, "rol/ror", etc


## Process injection:

Many malwares and security endpoint products use process injection to be able to inject code or libraries inside other processes, in windows and higher, it's not possible to inject into windows core processes such as explorer.exe or into users processes, but injecting into other of the users processes such as browsers and other non-core windows functions


Process injection allows bypassing of "trival" firewalls that block connections, to communicate with C&C and also evade debuggers, dynamic analysis or other monitoring tools by running code inside something that is not analysed.

It also let the attacker gain more insight into activity on the system by hooking the API in the legitime process and is also used to maintain persistence for fileless malware by injecting it's code into a a background process.

### DLL injection 

windows allows processes to load dynamic link libraries into other processes for security, sanboxing, graphics and other reasons, but this is naturally abused by malwares as well.

Following are some of the methods used by legitimate software

#### Windows-supported DLL injection: 

windows have special registry entries for DLL to load in every process that meets certain criteria, many of these also naturally allow malware to be loaded into multiple processes.

There are many of these, but the most common is:
+ HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\Windows\AppInit_DLLs(Requires admin)
+ HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\AppCertDlls(Requires admin)
+ HKEY_CURRENT_USER\Software\Classes\{AppName}\shellex\ContextMenuHandlers

AppInit_DLL:

This registry entry have been one of the most used entries by malwares to inject codes and persistence, the libraries specified there are loaded together with all the other processes that loads `user32.dll` which is the system used mainly for the UI.

in windows 7 the DLL required signing and from win8 and up they are disabled by default, but they can still be used by malware if it changes `RequireSignedAppInit_DLLs` to "False" and `LoadAppInit_DLLs` to "True", this however requires admin privileges.


AppCertDLL:

The library in this registry entry are loaded in each process that calls at least one of the following functions:
+ CreateProcess
+ CreateProcessAsUser
+ CreateProcessWithLogonW
+ CreateProcessWithTokenW
+ WinExec

This allows the malware to be injected into most browsers (as many of them create child processes to manage different tabs) and other applications as well. It still requires administrative privileges since HKEY_LOCAL_MACHINE is not writable for normal users on a Windows machine (Vista and above)

ContextMenuHandlers: 


`HKEY_CURRENT_USER\Software\Classes\{AppName}\shellex\ContextMenuHandlers`

This path loads a shell extension (a DLL file) in order to add additional features to the main Windows shell (explorer.exe). Basically, it can be misused to load the malware library as an extension to explorer.exe. This path can be easily created and modified without any administrative privileges.



#### Simple DLL injection

This method uses  the `LoadLibrary` API to load malicious libraries using Windows PE loader to execute it's entry point with the goal of to inject a path to the malicious DLL into the process using the `VirtualAllocEx` API and `WriteProcessMemory`. it then creates a thread into that process using `CreateRemoteThread` with the address of `LoadLibrary` API as the start address of the thread, when passing the DLL path as an argument to that thread, (which is passed to the `LoadLibrary` API), the WIndows PE loader will load that DLL into the process and execute the code

The steps the malware follow is generally like this:

1. Get the targeted process handle via its PID using the `OpenProcess` API. This handle will be used to access, read, and write to this process.
2. Allocate a space in that process virtual memory using the `VirtualAllocEx` API. This space will be used to write the full path of the malicious DLL file.
3. Write a path of the malware DLL to the process using the `WriteProcessMemory` API.
4. Load and execute this DLL using CreateRemoteThread and provide
5. the `LoadLibraryA` address as the start address, and the address of the DLL path as an argument.

Alternative APIs can also be used, for example, the undocumented `RtlCreateUserThread` instead of `CreateRemoteThread`.

This method is simple but will leave traces behind which can be uncovered by tools such as "listdlls.exe" from sysinternals as it's literally a file, many more advanced method nowadays use fileless methods which you can find further down below.

### Process injection

In this part we will go more into the more advanced methods malwares use to maintain persistence and stay invisible due to it's fileless nature, 

but first a quick note about how the malware get the list of running processes.

The following steps are used to gain insight into running processes:

1. make a snapshot using the `CreateToolhelp32Snapshot` API which capture all the currently running poccesses, names, PIDs and other information, this Api is usually executed by giving a argument to the `TH32CS_SNAPPROCESS`(this will not snapshot threads and loaded libaries).
2. Then get the first process in the returned list using the `Process32First` API which get the first process in the snapshot and starts the interation over the list of of processes.
3. loop the `Process32Next` API to get each process in the list one by one with it's name and PID.
4. Once the desired process have been found, the malware then goes to the next phase by executing the `OpenProcess` API with the PID of the processes. 


while this method sounds simliar to DLL injection, the difference is that this method inject a pieace of assembly code as array 2212of bytes and execute it using the `CreateRemoteThread` API and is "position-independent" or "PE-Independent as it have the ability to load it's own import table, access it's own data and execute malicious activity inside the target process.

the steps that the malware follows for this code injection method are: 

1. Search for the targeted process using `CreateToolhelp32Snapshot`, `Process32First`, and `Process32Next`.
2. Get the process handle using the `OpenProcess` API.
3. Allocate memory inside this process using `VirtualAllocEx` (or `CreateSectionEx`, which can be used in pretty much the same way) with the size of the whole piece of the assembly code to be injected.
4. Copy that code into the targeted process using `WriteProcessMemory`, as we have seen already.
5. Execute this code using the `CreateRemoteThread` API. Some malware gives the name or the PID of the malware process to this injected code so that it can terminate the malware (and possibly delete its file and all of its traces) to ensure there's no clear evidence of the malware's existence.

as you willsee, this method is very simliar to the DLL injection in regards to the steps used for process injection, but most of the hard work is in the piece of assembly code.

### Advanced code injection-reflective DLL injection

The position-independent code(shellcode) can also load malicious DLL into the targeted process's memory from memory rather then from the disk such as injecting a PE file together with a custom PE Loader which is implemented either as a shellcode or part of this file, this PE loader will be responsible for manually loading the payload.

malware starts by allocates memory with the size of the ImageBase and follows the PE loading steps including import table loading and fixing the relocation entries and while this method looks simliar in terms of results to DLL injection, it does not require the malicious DLL to be stored on the HDD and it don't leave usual traces of this DLL inside inside the Process Environment Block (PEB) and thus missed by memory forensics tools that only rely on PEB to detect DLLs.

### Process hollowing

This method was first seen with the stuxnet malware which continues to this day be very often used by various ATP's.

Process hollowing is essentially the process of locating a running process and then suspending that process before removing the loaded PE file from the memory and replaces it with a malicious one and then executing it as that process.

By doing this, the malicious malicious process can disguise itself as the legitimate process by using the same PEB(Process Environment Block) and the equivalent EPROCESS object still hold the information about the legitimate process which helps bypass firewalls and meory forensic tools.¨

The process of this kind of code injection are as follow:

1. Create a legitimate process in suspended mode, which creates the process and its first thread, but don't start the thread (the thread is in suspended mode)
2. Unload the legitimate application's memory image using `VirtualFreeEx` (hollowing out the process).
3. Allocate the same space in memory (the same as the unloaded PE image) for the malware PE image (the `VirtualAllocEx` API allows the malware to choose the preferred address to be allocated if it's free).
4. Inject the malware executable into that space by loading the PE file and fixing its import table (resolving it's relocation table if needed).
5. Change the thread's starting point to the malware's entry point using the `SetThreadContext` API. The `GetThreadContext` API allows the malware to get all of the registers' values, thread state, and all of the necessary information for the thread to be resumed after this, whereas the `SetThreadContext` API allows the malware to change these values, including the EIP/RIP register (instruction pointer) so that it can set it to the new entry point.
6. The last step is to resume this suspended thread to execute the malware from that point

This is the most well-known technique of process hollowing. There are other techniques that don't unload the actual process and include both the malware and the legitimate application executables together or use the CreateSection API to inject the malware code as an object.

## Dynamic analysis of code injection

Analsying process injection can be challenging due to the fact that the malwares changes from a debugged process to one that is not debugged.

to combat this problem, there's couple of options;

Method 1: Debug in place

This method is a preffered method by many as it allow you to debug the the shellcode by tricking the malware into injecting the shellcode into it's own memory and thus you are able to contain it within the debgugged area.

Generally, malware injects its shellcode inside another process and executes it from a specific point in that shellcode. We can locate that shellcode inside the malware's binary (or memory if it gets decrypted) and just set the EIP/RIP register (New origin here in OllyDbg) to this shellcode's entry point and continue the execution from there. It allows us to execute this shellcode inside a debugged process and even bypass some checks for the name of the process this shellcode is supposed to run in.

the steps tp do this method is as follow:

1. Once the malware calls VirtualAllocEx to allocate space for the shellcode in the targeted process memory, save the returned address of that allocated space (let's say the returned address was 0x300000).
2. Set a breakpoint on `WriteProcessMemory` and save the source and the destination addresses. The source address is the address of that shellcode inside the malware process's memory (let's say 0x450000) and the destination will probably be the returned address from `VirtualAllocEx`.
3. Now, set a breakpoint on `CreateRemoteThread` and get the entry point (and the arguments, if there are any) of that shellcode in the targeted process (let's say it will be 0x30012F).
4. Now, calculate the entry point's address inside the malware process's memory, which in this case will be 0x30012F - 0x300000 + 0x450000 = 0x45012F.
5. If a virtual machine is used for debugging (which is definitely recommended), save a snapshot and then set the EIP value to the shellcode's EntryPoint (0x45012F), set any necessary arguments, and continue debugging from there.


while this method is simple and easy to debug and handle, it only works with simple shellcodes and does not work with multiple injections(multiple calls of `WriteProcessMemory`), process hollowing or with complicated argument, it also needs cautious debugging after it to avoid bugsd and errors from having the shellcode running in a process different from the intented one.

Method 2: Attach to the targeted process

Another simple solution is to attach to the target process before the malware executes `CreateRemoteThread` or modify the `CreateRemoteThread`'s creation flags to `CREATE_SUSPENDED` like this: 

```
CreateRemoteThread(Process, NULL, NULL,
(LPTHREAD_START_ROUTINE)LoadLibrary, (LPVOID)Memory, CREATE_SUSPENDED,
NULL);
```

To be able to do so, we need to know the targeted process that the malware will inject into. This means that we need to set breakpoints on the `Process32First` and `Process32Next` APIs and analyze the code in-between searching for the APIs, such as `strcmp` or equivalent code, to find the required process to inject into. Not all calls are just for process injection; for example, they can also be used as an anti-reverse engineering trick.


## Dealing with process hollowing

The mentioned method earlier can not deal with process hollowing as the malware creates a new process in a suspended state, so it won't appear in debuggers which make it hard to attach to it before the malware executes and detach from debugger.

The best way to deal with this is to set BreakPoint on `WriteProcessMemory` and dump the PE file before it's loaded into the target process memory, once the breakpoint is triggered, follow the source argument of `WriteProcessMemory` and scroll up until the start of the PE file is found which usually can be recognized by `MZ` signature and `This program cannot run in DOS mode`

Some malwares use `createSection` and `MapViewOfSection` instead of `WriteMemoryProcess`, these API's create a memory object that the malicious executeable can be written into. This memory object can also be mapped to another process as well. So after the malware writes the malicious PE image to the memory object, it maps it into the targeted process and then uses `CreateRemoteThread` to start execution from it's entry point.

In this case, we can set a breakpoint on `MapViewOfSection` to get the returned address of the mapped memory object (before the malware writes any data to this memory object). Now, it is possible to set a breakpoint or write on this returned address in order to catch any writing operation to this memory object (writing to this memory object is equivalent to `WriteProcessMemory`).

Once your breakpoint on write hits, we can find what data is getting written to this
memory object (most probably a PE file in the case of process hollowing) and the source of
the data that contains all of the PE files that are unloaded so that we can easily dump it to
disk and load it in a debugger as if it was injected into another process.

This Method, is all about finding the PE file before it gets loaded and dumping it
as a normal executable file. once that is done, we get the second stage payload which can then be debugged or statically analyzed

### Memory forensic with Volatility

While the purpose of process injection and hollowing is to hide from memory forensic it can be challenging to detect it, but with tools such as Volatility, it's possible.

The main things that helps in uncovering injections are the fact that the allocated memory with the shellcode or loaded DLL is always allocated with the "EXECUTE" permission and don't represent a mapped file. when a modules such as a executable get loaded using Windows PE Loader, it get's loaded with an "IMAGE" flag to represent that it's a memory map of a executable file, normally when such memory page get allocated, it use the `VirtualAlloc` API and get's allocated with a "PRIVATE" flag to show it's allocated for data, it's uncommon for Private allocated memory to have the "EXECUTE" permission, also not common to see "WRITE" permission along with "EXECUTE" permission(`READ_WRITE_EXECUTE`) which most shellcode injections have.

By using the "`malfind` command in the "volatility" tool, you can find hidden and injected code inside a process or entire system and you can dump all memory images inside this process using the vaddump command.

This command dumps all memory regions inside the process, following the EPROCESS kernel object for that process and its virtual memory map (and its equivalent physical memory pages) using what's called Virtual Address Descriptors (VADs), which are simply mappers between virtual memory and their equivalent physical memory. vaddump will dump all of the memory regions into a separate file.

For injected PE files, we can dump them to disk (and reconstruct their headers and sections back, but not import tables) using dlldump instead of vaddump

After that, we will have a memory dump of the malware PE file (or shellcode) to scan and analyze. It's not a perfect dump, but we can scan it with strings tool or perform static analysis on it. We may need to fix the addresses of the import table manually by patching these addresses in debuggers such as OllyDbg and dumping them again or directly debugging them.

## Anti Analysis Notes

This section will have various notes about things related to analysing of malwares and various things to note in regards to anti-analysis

String anti analysis:
+ many malware tries to hide strings by pushing them onto the stack, so this is something which may be the case if you see alot of push instructions

