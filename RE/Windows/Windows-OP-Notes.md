## this document is for all notes in relation to how windows operates and so forth


# processes

## What's process?
A process is not just a representation of a running program in memory, but is also a container of all the information of the running application. This container encapsulates all the virtual memory for that process (each process in Windows x86 has an address space of 4 GB and on x64, it is 16 TB) and their equivalent physical memory. It includes all the loaded DLLs, opened files, opened sockets, the list of threads running in this process, the process ID, and much more.

A process is basically a structure in the kernel that holds all of this information inside,
working as an entity to represent this running executable file.

## Threads
A process without a running thread is like a dead body. A thread is not only the entity that represents an execution path inside a process (and each process can have one or more threads running simultaneously), but also a structure in the kernel that saves the whole state of that execution, including the registers, stack information, and the last error.

Each thread in Windows has a small time frame to run before it gets stopped to have another thread resumed (as the number of processor cores is much smaller than the number of threads running in the entire system). When Windows changes the execution from one thread to another, it takes a snapshot of the whole execution state (registers, stack, instruction pointer, and so on) and saves it in the thread structure to be able to resume it again from where it stopped.

All threads running in one process share the same resources of that process, including the virtual memory, open files, open sockets, DLLs, mutexes, and others, and they synchronize between each other on accessing these resources.

Each thread has its own stack, instruction pointer, code functions for error handling, its own thread ID, and thread information structure called TEB

### TIB, TEB, and PEB Data Structures
Another thing related to processes and threads of importance are the data structures (TIB, TEB, and PEB). These structures are stored inside the process memory and accessible through its code. Their main function is to include all the information about the process and each thread and make them accessible to the code so that it can easily know the process filename, the loaded DLLs, and other related information.

They are all accessible through a special segment register FS, like this:
```
mov eax, DWORD PTR FS:[XX]
```

And these data structures have the following functions:

Thread Information Block (TIB): 
+ Contains some information about the thread, including the list of functions that are used for error handling and much more

Thread Environment Block (TEB): 
+ Has more information about the thread, including the thread ID 

Process Environment Block (PEB):
+ Includes information about the process, such as the process name, process ID (PID), loaded modules (all PE files loaded in the memory including the program itself and its DLLs), and much more

# Memory

## Virtual Memory

Virtual memory is like a holder for each process. Each process has its own virtual memory space for this process, its related libraries, and all memory allocated for this process from the stack, heap, and private memory.

Virtual memory is like a holder for each process. Each process has its own virtual memory space for this process, its related libraries, and all memory allocated for this process from the stack, heap, and private memory. This virtual memory has a mapper to the equivalent physical memory. Not all virtual memory pages are mapped to physical memory, and each mapped one has its own permission (READ|WRITE, READ|EXECUTE, or maybe READ|WRITE|EXECUTE).

Virtual memory allows you to create a security layer between one process and another and allows the operating system to manage different processes and suspend one process to give resources to another.

# Process loading

## Process loading steps

a process loading is happening in the following order:

1: Starting the program:
+ When you double-click on a program in Windows Explorer, let's say calc.exe, another process called explorer.exe (the process of Windows Explorer) calls an API called CreateProcess, which gives the operating system the request to create this process and start the execution.

2: Creating the process data structures:
+ Windows then creates the process data structure in the kernel (which is called EProcess) and sets a unique ID for this process (ProcessID), and sets the explorer.exe process ID as a parent PID for the newly created calc.exe process.

3: Initialize the virtual memory: 
+ Then, Windows creates the process, virtual memory and its representation of the physical memory and saves it inside the EProcess structure, creates the PEB structure with all necessary information, and then loads the main two DLLs that Windows applications will always need, which are ntdll.dll and kernel32.dll (some applications run on other Windows subsystems, such as POSIX, and they don't use kernel32.dll).

4: Loading the PE file:
+ After that, Windows starts loading the PE file (which we will explain next), loading all the required third-party libraries (DLLs), including all DLLs these libraries require, and makes sure to find the required APIs from these libraries and save their addresses in the import table of the loaded PE file so the code can easily access them and call them.

5: Start the execution:
+ Last but not least, Windows creates the first thread in the process, which does some initialization and calls the PE file's entry point to start the execution of the program.

## PE file loading steps

The Windows PE loader follows these steps while loading an executable PE file into memory (including dynamic link libraries):

1: Parsing the headers: 

Windows first starts with parsing the DOS header to find the PE header and then parses the PE header (File header and Optional header) to gather some important information:
+ ImageBase: To load the PE file (if possible) at this address in it's virtual memory.
+ NoOfSections: To be used in loading the sections.
+ SizeOfImage: As this will be the final size of the whole PE file after being loaded in memory, this value will be used to allocate the space initially.

2: Parsing section table: 

+ Using the NoOfSections field, it parses all the sections in the PE file and makes sure to get all the necessary information, including their addresses and sizes in memory (VirtualAddress and VirtualSize respectively), as well as the pointer and the size of the section on the hard disk for reading its data.

3: Mapping the file in memory:

+ Using SectionAlignment, the loader copies all the headers and then moves each section to a new place using its VirtualAddress and VirtualSize values (if VirtualAddress or VirtualSize are not aligned with SectionAlignment, the loader will align them first and then use them)

4: Dealing with third-party libraries: 

+ In this step, the loader loads all the required DLLs, going through this process again and again recursively until all DLLs are loaded. After that, it gets the addresses of all the required APIs and saves them in the import table of the loaded PE file.

5: Dealing with relocation:

If the program or any third-party library has a relocation table (in its Data directory) and is loaded in a different place than its ImageBase, the loader fixes all the absolute addresses in the code with the new address of the program/library (with the new ImageBase).

6: Start the execution:
+ In the last step, as in the process creation, Windows creates the first thread, which executes the program from its entry point. Some antireverse engineering techniques can force it to start somewhere else before.

## 32-bit loading on 64-bit

To be able to load 32-bit applications on 64-bit system, windows have something called "WOW64(Windows On Windows 64) emulator", this emulator consist of following files
+ wow64.dll
+ wow64cpu.dll
+ wow64win.dll

These DLLs basically create a simulated environment for the 32-bit process, which includes a 32-bit ntdll.dll and a 32-bit kernel32.dll.

These DLLs, rather than connecting directly to the Windows kernel, call an API X86SwitchTo64BitMode, which then switches to x64 and calls the 64-bit ntdll.dll, which communicates directly to the kernel-

Also, WOW64-sandboxed processes (x86 processes running in x64 environment) introduced new APIs, such as IsWow64Process, which is used by malware to identify if it's running as a 32-bit process in an x64 environment, or in an x86 environment. And it introduced multiple new APIs as well specific for WOW64 environment.


# Services

Services are tasks that are generally supposed to execute certain logic in the background, similar to daemons on Linux. So, there is no surprise that malware authors commonly use them to achieve reliable persistence.

Services are controlled by the Service Control Manager (SCM) implemented in
+ %SystemRoot%\System32\services.exe

All services have the corresponding registry key
+ HKLM\SYSTEM\CurrentControlSet\services\{service_name}.

It contains multiple values describing the service, including the following:
+ ImagePath: A file path to the corresponding executable with optional arguments

Type: The REG_DWORD value specifies the type of the service. Examples of supported values include the following:
+ 0x00000001 (kernel): In this case, the logic is implemented in a driver (which will be covered in more detail in Chapter 6, Understanding Kernel-Mode Rootkits, which is dedicated to kernelmode threats).
+ 0x00000010 (own): The service runs in its own process.
+ 0x00000020 (share): The service runs in a shared process.

Start: Another REG_DWORD value, which describes the way the service is supposed to start. The following options are commonly used:
+ 0x00000000 (boot) and 0x00000001 (system): These values are used for drivers. In this case, they will be loaded by the boot loader or during the kernel initialization respectively.
+ 0x00000002 (auto): The service will start automatically each time the machine restarts, the obvious choice for malware.
+ 0x00000003 (demand): Specifies a service that should be started manually. This option is particularly useful for debugging.
+ 0x00000004 (disabled): The service won't be started.

There are several ways the services are commonly designed:

As an executable: Here, the actual logic is implemented in a dedicated executable file, and the previously-mentioned ImagePath will contain its full file path.

As a DLL (own loader): 
+ In this case, the service logic is located in the DLL that has its own loader (either a custom program or some standard one like rundll32.exe). The full command line is stored in the ImagePath key, same as in the previous case

+ As a DLL (svchost):
+ Here, instead of having its own EXE file, all service logic is implemented in a DLL loaded into the address space of one of the svchost.exe processes. In order to be loaded, malware generally creates a new group in the HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost registry key and later passes this value to the svchost.exe using the "-k" argument. 

    The path to the DLL will be specified not in the ImagePath value of the service registry key as in the previous case (here, it will contain the path of the svchost.exe with the service group argument) but in the ServiceDll value of the HKLM\SYSTEM\CurrentControlSet\services\<service_name>\Parameter s registry key. The service DLL should contain the ServiceMain export function (if the custom name is used, it should be specified in the ServiceMain registry value). If the SvchostPushServiceGlobals export is present, it will be executed before ServiceMain.

A user-mode service with a dedicated executable (or a DLL with its own loader) can be registered using the standard sc command line tool like this:

"`sc create <service_name> type= own binpath= <path_to_executable>`"

The process is slightly more complicated for svchost DLL based services:

`reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost" /v "<service_group>" /t REG_MULTI_SZ /d "<service_name>\0" /f reg add "HKLM\SYSTEM\CurrentControlSet\Services\<service_name>\Parameters" /v ServiceDll /t REG_EXPAND_SZ /d <path_to_dll> /f sc create <service_name> type= share binpath= "C:\Windows\System32\svchost.exe -k <service_group>"`

Using this approach, the created service can be started on demand when necessary, for example, by using the following commands: 

`sc start <service_name>` OR "`net start <service_name_or_display_name>>`"

# Notes from page 90-91 of "mastering malware analysis" are not taken and need to be gone over again





